<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# utils

```go
import "github.com/fufuok/utils"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func B2S\(b \[\]byte\) string](<#B2S>)
- [func B64Decode\(s string\) \[\]byte](<#B64Decode>)
- [func B64Encode\(b \[\]byte\) string](<#B64Encode>)
- [func B64UrlDecode\(s string\) \[\]byte](<#B64UrlDecode>)
- [func B64UrlEncode\(b \[\]byte\) string](<#B64UrlEncode>)
- [func BeginOfDay\(t time.Time\) time.Time](<#BeginOfDay>)
- [func BeginOfHour\(t time.Time\) time.Time](<#BeginOfHour>)
- [func BeginOfLastMonth\(t time.Time\) time.Time](<#BeginOfLastMonth>)
- [func BeginOfLastWeek\(t time.Time\) time.Time](<#BeginOfLastWeek>)
- [func BeginOfMinute\(t time.Time\) time.Time](<#BeginOfMinute>)
- [func BeginOfMonth\(t time.Time\) time.Time](<#BeginOfMonth>)
- [func BeginOfNextMonth\(t time.Time\) time.Time](<#BeginOfNextMonth>)
- [func BeginOfNextWeek\(t time.Time\) time.Time](<#BeginOfNextWeek>)
- [func BeginOfSecond\(t time.Time\) time.Time](<#BeginOfSecond>)
- [func BeginOfTomorrow\(t time.Time\) time.Time](<#BeginOfTomorrow>)
- [func BeginOfWeek\(t time.Time\) time.Time](<#BeginOfWeek>)
- [func BeginOfYear\(t time.Time\) time.Time](<#BeginOfYear>)
- [func BeginOfYesterday\(t time.Time\) time.Time](<#BeginOfYesterday>)
- [func BigComma\(b \*big.Int\) string](<#BigComma>)
- [func BigCommaf\(v \*big.Float\) string](<#BigCommaf>)
- [func Bigoom\(n, b \*big.Int\) \(float64, int\)](<#Bigoom>)
- [func CPUTicks\(\) int64](<#CPUTicks>)
- [func CallPath\(\) string](<#CallPath>)
- [func CheckDomain\(name string\) error](<#CheckDomain>)
- [func Comma\(v int64\) string](<#Comma>)
- [func Commaf\(v float64\) string](<#Commaf>)
- [func Commai\(v int\) string](<#Commai>)
- [func Commau\(v uint64\) string](<#Commau>)
- [func CopyB2S\(b \[\]byte\) string](<#CopyB2S>)
- [func CopyBytes\(b \[\]byte\) \[\]byte](<#CopyBytes>)
- [func CopyS2B\(s string\) \[\]byte](<#CopyS2B>)
- [func CopyString\(s string\) string](<#CopyString>)
- [func CutBytes\(s, sep \[\]byte\) \(before, after \[\]byte, found bool\)](<#CutBytes>)
- [func CutString\(s, sep string\) \(before, after string, found bool\)](<#CutString>)
- [func DaysInMonth\(year int, m time.Month\) int](<#DaysInMonth>)
- [func DaysInYear\(year int\) int](<#DaysInYear>)
- [func EncodeUUID\(id \[\]byte\) \[\]byte](<#EncodeUUID>)
- [func EndOfDay\(t time.Time\) time.Time](<#EndOfDay>)
- [func EndOfHour\(t time.Time\) time.Time](<#EndOfHour>)
- [func EndOfLastMonth\(t time.Time\) time.Time](<#EndOfLastMonth>)
- [func EndOfLastWeek\(t time.Time\) time.Time](<#EndOfLastWeek>)
- [func EndOfMinute\(t time.Time\) time.Time](<#EndOfMinute>)
- [func EndOfMonth\(t time.Time\) time.Time](<#EndOfMonth>)
- [func EndOfNextMonth\(t time.Time\) time.Time](<#EndOfNextMonth>)
- [func EndOfNextWeek\(t time.Time\) time.Time](<#EndOfNextWeek>)
- [func EndOfSecond\(t time.Time\) time.Time](<#EndOfSecond>)
- [func EndOfTomorrow\(t time.Time\) time.Time](<#EndOfTomorrow>)
- [func EndOfWeek\(t time.Time\) time.Time](<#EndOfWeek>)
- [func EndOfYear\(t time.Time\) time.Time](<#EndOfYear>)
- [func EndOfYesterday\(t time.Time\) time.Time](<#EndOfYesterday>)
- [func EqualFold\(b, s string\) bool](<#EqualFold>)
- [func EqualFoldBytes\(b, s \[\]byte\) bool](<#EqualFoldBytes>)
- [func Executable\(evalSymlinks ...bool\) string](<#Executable>)
- [func ExecutableDir\(evalSymlinks ...bool\) string](<#ExecutableDir>)
- [func FastIntn\(n int\) int](<#FastIntn>)
- [func FastRand\(\) uint32](<#FastRand>)
- [func FastRand64\(\) uint64](<#FastRand64>)
- [func FastRandn\(n uint32\) uint32](<#FastRandn>)
- [func FastRandu\(\) uint](<#FastRandu>)
- [func FirstString\(s, sep string, defaultStr ...string\) string](<#FirstString>)
- [func GetBytes\(v interface\{\}, defaultVal ...\[\]byte\) \[\]byte](<#GetBytes>)
- [func GetDomain\(name string\) string](<#GetDomain>)
- [func GetIPPort\(addr net.Addr\) \(ip net.IP, port int, err error\)](<#GetIPPort>)
- [func GetInt\(v interface\{\}, defaultInt ...int\) int](<#GetInt>)
- [func GetMonthDays\(t time.Time\) int](<#GetMonthDays>)
- [func GetNotInternalIPv4\(ip, defaultIP net.IP, flag ...bool\) net.IP](<#GetNotInternalIPv4>)
- [func GetNotInternalIPv4String\(ip, defaultIP string, flag ...bool\) string](<#GetNotInternalIPv4String>)
- [func GetSafeB2S\(b \[\]byte, defaultVal ...string\) string](<#GetSafeB2S>)
- [func GetSafeBytes\(b \[\]byte, defaultVal ...\[\]byte\) \[\]byte](<#GetSafeBytes>)
- [func GetSafeS2B\(s string, defaultVal ...\[\]byte\) \[\]byte](<#GetSafeS2B>)
- [func GetSafeString\(s string, defaultVal ...string\) string](<#GetSafeString>)
- [func GetString\(v interface\{\}, defaultVal ...string\) string](<#GetString>)
- [func GoroutineID\(\) \(uint64, error\)](<#GoroutineID>)
- [func Gzip\(data \[\]byte\) \(\[\]byte, error\)](<#Gzip>)
- [func GzipLevel\(data \[\]byte, level int\) \(dst \[\]byte, err error\)](<#GzipLevel>)
- [func HumanBaseBytes\(v uint64, base float64, sizes \[\]string\) string](<#HumanBaseBytes>)
- [func HumanBigBytes\(s \*big.Int\) string](<#HumanBigBytes>)
- [func HumanBigIBytes\(s \*big.Int\) string](<#HumanBigIBytes>)
- [func HumanBigKbps\(s \*big.Int\) string](<#HumanBigKbps>)
- [func HumanBytes\(v uint64\) string](<#HumanBytes>)
- [func HumanGBMB\(v uint64\) string](<#HumanGBMB>)
- [func HumanIBytes\(v uint64\) string](<#HumanIBytes>)
- [func HumanIntBytes\(v int\) string](<#HumanIntBytes>)
- [func HumanIntIBytes\(v int\) string](<#HumanIntIBytes>)
- [func HumanIntKbps\(v int\) string](<#HumanIntKbps>)
- [func HumanKbps\(v uint64\) string](<#HumanKbps>)
- [func ID\(\) uint64](<#ID>)
- [func IPv42Long\(ip net.IP\) int](<#IPv42Long>)
- [func IPv42LongLittle\(ip net.IP\) int](<#IPv42LongLittle>)
- [func IPv4String2Long\(ip string\) int](<#IPv4String2Long>)
- [func IPv4String2LongLittle\(ip string\) int](<#IPv4String2LongLittle>)
- [func IPv62Int\(ip net.IP\) \*big.Int](<#IPv62Int>)
- [func IPv6String2Int\(ip string\) \*big.Int](<#IPv6String2Int>)
- [func InIPNet\(ip net.IP, ipNets map\[\*net.IPNet\]struct\{\}\) bool](<#InIPNet>)
- [func InIPNetString\(ip string, ipNets map\[\*net.IPNet\]struct\{\}\) bool](<#InIPNetString>)
- [func InInts\(slice \[\]int, n int\) bool](<#InInts>)
- [func InStrings\(ss \[\]string, s string\) bool](<#InStrings>)
- [func InitCSTLocation\(\) \(name string, loc \*time.Location, cst \*time.Location, ok bool\)](<#InitCSTLocation>)
- [func InitLocation\(name string\) \(\*time.Location, bool\)](<#InitLocation>)
- [func Int2IPv6\(ipInt \*big.Int\) net.IP](<#Int2IPv6>)
- [func Int2IPv6String\(n \*big.Int\) string](<#Int2IPv6String>)
- [func IsIP\(ip string\) bool](<#IsIP>)
- [func IsIPv4\(s string\) bool](<#IsIPv4>)
- [func IsIPv6\(s string\) bool](<#IsIPv6>)
- [func IsInternalIPv4\(ip net.IP\) bool](<#IsInternalIPv4>)
- [func IsInternalIPv4String\(ip string\) bool](<#IsInternalIPv4String>)
- [func IsLeapYear\(year int\) bool](<#IsLeapYear>)
- [func IsLetter\(s string\) bool](<#IsLetter>)
- [func IsLetterOrNumeric\(s string\) bool](<#IsLetterOrNumeric>)
- [func IsNumeric\(s string\) bool](<#IsNumeric>)
- [func IsPrivateIP\(ip net.IP\) bool](<#IsPrivateIP>)
- [func IsPrivateIPString\(ip string\) bool](<#IsPrivateIPString>)
- [func JoinBytes\(b ...\[\]byte\) \[\]byte](<#JoinBytes>)
- [func JoinString\(s ...string\) string](<#JoinString>)
- [func JoinStringBytes\(s ...string\) \[\]byte](<#JoinStringBytes>)
- [func LastString\(s, sep string, defaultStr ...string\) string](<#LastString>)
- [func LeftPad\(s, pad string, n int\) string](<#LeftPad>)
- [func LeftPadBytes\(b, pad \[\]byte, n int\) \[\]byte](<#LeftPadBytes>)
- [func Logn\(n, b float64\) float64](<#Logn>)
- [func Long2IPv4\(n int\) net.IP](<#Long2IPv4>)
- [func Long2IPv4String\(n int\) string](<#Long2IPv4String>)
- [func LongLittle2IPv4\(n int\) net.IP](<#LongLittle2IPv4>)
- [func LongLittle2IPv4String\(n int\) string](<#LongLittle2IPv4String>)
- [func MaxInt\(a, b int\) int](<#MaxInt>)
- [func MinInt\(a, b int\) int](<#MinInt>)
- [func MustBool\(v interface\{\}\) bool](<#MustBool>)
- [func MustInt\(v interface\{\}\) int](<#MustInt>)
- [func MustJSON\(v interface\{\}\) \[\]byte](<#MustJSON>)
- [func MustJSONIndent\(v interface\{\}\) \[\]byte](<#MustJSONIndent>)
- [func MustJSONIndentString\(v interface\{\}\) string](<#MustJSONIndentString>)
- [func MustJSONString\(v interface\{\}\) string](<#MustJSONString>)
- [func MustParseHumanBigBytes\(s string, defaultVal ...\*big.Int\) \*big.Int](<#MustParseHumanBigBytes>)
- [func MustParseHumanBytes\(s string, defaultVal ...uint64\) uint64](<#MustParseHumanBytes>)
- [func MustString\(v interface\{\}, timeLayout ...string\) string](<#MustString>)
- [func NanoTime\(\) int64](<#NanoTime>)
- [func NewRand\(seed ...int64\) \*rand.Rand](<#NewRand>)
- [func Pad\(s, pad string, n int\) string](<#Pad>)
- [func PadBytes\(s, pad \[\]byte, n int\) \[\]byte](<#PadBytes>)
- [func ParseHostPort\(s string\) \(net.IP, uint16, bool, error\)](<#ParseHostPort>)
- [func ParseHumanBigBytes\(s string\) \(\*big.Int, error\)](<#ParseHumanBigBytes>)
- [func ParseHumanBytes\(s string\) \(uint64, error\)](<#ParseHumanBytes>)
- [func ParseIP\(s string\) \(net.IP, bool\)](<#ParseIP>)
- [func ParseIPv4\(ip string\) net.IP](<#ParseIPv4>)
- [func ParseIPv6\(ip string\) net.IP](<#ParseIPv6>)
- [func ParseIPx\(s string\) \(net.IP, bool\)](<#ParseIPx>)
- [func ParseIPxWithNumeric\(s string\) \(net.IP, bool\)](<#ParseIPxWithNumeric>)
- [func ParseInts\(s string\) \(\[\]int, error\)](<#ParseInts>)
- [func RandAlphaBytes\(n int\) \[\]byte](<#RandAlphaBytes>)
- [func RandAlphaString\(n int\) string](<#RandAlphaString>)
- [func RandBytes\(n int\) \[\]byte](<#RandBytes>)
- [func RandBytesLetters\(n int, letters string\) \[\]byte](<#RandBytesLetters>)
- [func RandDecBytes\(n int\) \[\]byte](<#RandDecBytes>)
- [func RandDecString\(n int\) string](<#RandDecString>)
- [func RandHexBytes\(n int\) \[\]byte](<#RandHexBytes>)
- [func RandHexString\(n int\) string](<#RandHexString>)
- [func RandInt\(min, max int\) int](<#RandInt>)
- [func RandString\(n int\) string](<#RandString>)
- [func RandUint32\(min, max uint32\) uint32](<#RandUint32>)
- [func Recover\(cb ...RecoveryCallback\)](<#Recover>)
- [func RemoveString\(ss \[\]string, s string\) \(\[\]string, bool\)](<#RemoveString>)
- [func ReplaceHost\(a, b string\) string](<#ReplaceHost>)
- [func Reverse\(s string\) string](<#Reverse>)
- [func RightPad\(s, pad string, n int\) string](<#RightPad>)
- [func RightPadBytes\(b, pad \[\]byte, n int\) \[\]byte](<#RightPadBytes>)
- [func Round\(v float64, precision int\) float64](<#Round>)
- [func RunPath\(\) string](<#RunPath>)
- [func RuneReverse\(s string\) string](<#RuneReverse>)
- [func RuneSubString\(s string, length int, suffix string\) string](<#RuneSubString>)
- [func S2B\(s string\) \[\]byte](<#S2B>)
- [func SafeGo\(fn func\(\), cb ...RecoveryCallback\)](<#SafeGo>)
- [func SafeGoCommonFunc\(args interface\{\}, fn func\(args interface\{\}\), cb ...RecoveryCallback\)](<#SafeGoCommonFunc>)
- [func SafeGoWithContext\(ctx context.Context, fn func\(ctx context.Context\), cb ...RecoveryCallback\)](<#SafeGoWithContext>)
- [func SearchInt\(slice \[\]int, n int\) int](<#SearchInt>)
- [func SearchString\(ss \[\]string, s string\) int](<#SearchString>)
- [func Sleep\(ctx context.Context, interval time.Duration\) error](<#Sleep>)
- [func SplitHostPort\(hostPort string\) \(host, port string\)](<#SplitHostPort>)
- [func SumInt\(v ...int\) int](<#SumInt>)
- [func ToLower\(b string\) string](<#ToLower>)
- [func ToLowerBytes\(b \[\]byte\) \[\]byte](<#ToLowerBytes>)
- [func ToUpper\(b string\) string](<#ToUpper>)
- [func ToUpperBytes\(b \[\]byte\) \[\]byte](<#ToUpperBytes>)
- [func Trim\(s string, cutset byte\) string](<#Trim>)
- [func TrimBytes\(b \[\]byte, cutset byte\) \[\]byte](<#TrimBytes>)
- [func TrimLeft\(s string, cutset byte\) string](<#TrimLeft>)
- [func TrimLeftBytes\(b \[\]byte, cutset byte\) \[\]byte](<#TrimLeftBytes>)
- [func TrimRight\(s string, cutset byte\) string](<#TrimRight>)
- [func TrimRightBytes\(b \[\]byte, cutset byte\) \[\]byte](<#TrimRightBytes>)
- [func TrimSlice\(ss \[\]string\) \[\]string](<#TrimSlice>)
- [func TruncStr\(s string, maxLen int, suffix string\) string](<#TruncStr>)
- [func UUID\(\) \[\]byte](<#UUID>)
- [func UUIDShort\(\) string](<#UUIDShort>)
- [func UUIDSimple\(\) string](<#UUIDSimple>)
- [func UUIDString\(\) string](<#UUIDString>)
- [func Ungzip\(data \[\]byte\) \(src \[\]byte, err error\)](<#Ungzip>)
- [func Unzip\(data \[\]byte\) \(src \[\]byte, err error\)](<#Unzip>)
- [func ValidOptionalPort\(port string\) bool](<#ValidOptionalPort>)
- [func WaitNextMinute\(t ...time.Time\)](<#WaitNextMinute>)
- [func WaitNextMinuteWithTime\(t ...time.Time\) \(now time.Time\)](<#WaitNextMinuteWithTime>)
- [func WaitNextSecond\(t ...time.Time\)](<#WaitNextSecond>)
- [func WaitNextSecondWithTime\(t ...time.Time\) \(now time.Time\)](<#WaitNextSecondWithTime>)
- [func WaitSignal\(sig ...os.Signal\) os.Signal](<#WaitSignal>)
- [func WaitUntilMinute\(m int, t ...time.Time\)](<#WaitUntilMinute>)
- [func WaitUntilSecond\(s int, t ...time.Time\)](<#WaitUntilSecond>)
- [func Zip\(data \[\]byte\) \(\[\]byte, error\)](<#Zip>)
- [func ZipLevel\(data \[\]byte, level int\) \(dst \[\]byte, err error\)](<#ZipLevel>)
- [type Bool](<#Bool>)
  - [func NewBool\(val bool\) \*Bool](<#NewBool>)
  - [func NewFalse\(\) \*Bool](<#NewFalse>)
  - [func NewTrue\(\) \*Bool](<#NewTrue>)
  - [func \(x \*Bool\) CAS\(old, new bool\) bool](<#Bool.CAS>)
  - [func \(x \*Bool\) CompareAndSwap\(old, new bool\) \(swapped bool\)](<#Bool.CompareAndSwap>)
  - [func \(x \*Bool\) Load\(\) bool](<#Bool.Load>)
  - [func \(x \*Bool\) MarshalJSON\(\) \(\[\]byte, error\)](<#Bool.MarshalJSON>)
  - [func \(x \*Bool\) Store\(val bool\)](<#Bool.Store>)
  - [func \(x \*Bool\) StoreFalse\(\)](<#Bool.StoreFalse>)
  - [func \(x \*Bool\) StoreTrue\(\)](<#Bool.StoreTrue>)
  - [func \(x \*Bool\) String\(\) string](<#Bool.String>)
  - [func \(x \*Bool\) Swap\(new bool\) \(old bool\)](<#Bool.Swap>)
  - [func \(x \*Bool\) Toggle\(\) \(old bool\)](<#Bool.Toggle>)
  - [func \(x \*Bool\) UnmarshalJSON\(b \[\]byte\) error](<#Bool.UnmarshalJSON>)
- [type NoCmp](<#NoCmp>)
- [type NoCopy](<#NoCopy>)
  - [func \(\*NoCopy\) Lock\(\)](<#NoCopy.Lock>)
  - [func \(\*NoCopy\) Unlock\(\)](<#NoCopy.Unlock>)
- [type RecoveryCallback](<#RecoveryCallback>)
- [type TryMutex](<#TryMutex>)
  - [func NewTryMutex\(\) \*TryMutex](<#NewTryMutex>)
  - [func \(m \*TryMutex\) Lock\(\)](<#TryMutex.Lock>)
  - [func \(m \*TryMutex\) TryLock\(timeout ...time.Duration\) bool](<#TryMutex.TryLock>)
  - [func \(m \*TryMutex\) Unlock\(\)](<#TryMutex.Unlock>)


## Constants

<a name="Byte"></a>Ref: dustin/go\-humanize IEC Sizes. kibis of bits

```go
const (
    Byte = 1 << (iota * 10)
    KiByte
    MiByte
    GiByte
    TiByte
    PiByte
    EiByte
)
```

<a name="IByte"></a>SI Sizes.

```go
const (
    IByte = 1
    KByte = IByte * 1000
    MByte = KByte * 1000
    GByte = MByte * 1000
    TByte = GByte * 1000
    PByte = TByte * 1000
    EByte = PByte * 1000
)
```

<a name="IPv4Min"></a>

```go
const (
    IPv4Min = 0
    IPv4Max = 1<<32 - 1
)
```

<a name="PtrSize"></a>

```go
const (
    // PtrSize 4 on 32-bit systems, 8 on 64-bit.
    PtrSize = 4 << (^uintptr(0) >> 63)
)
```

## Variables

<a name="BigByte"></a>Ref: dustin/go\-humanize

```go
var (

    // BigByte is one byte in bit.Ints
    BigByte = big.NewInt(1)
    // BigKiByte is 1,024 bytes in bit.Ints
    BigKiByte = (&big.Int{}).Mul(BigByte, bigIECExp)
    // BigMiByte is 1,024 k bytes in bit.Ints
    BigMiByte = (&big.Int{}).Mul(BigKiByte, bigIECExp)
    // BigGiByte is 1,024 m bytes in bit.Ints
    BigGiByte = (&big.Int{}).Mul(BigMiByte, bigIECExp)
    // BigTiByte is 1,024 g bytes in bit.Ints
    BigTiByte = (&big.Int{}).Mul(BigGiByte, bigIECExp)
    // BigPiByte is 1,024 t bytes in bit.Ints
    BigPiByte = (&big.Int{}).Mul(BigTiByte, bigIECExp)
    // BigEiByte is 1,024 p bytes in bit.Ints
    BigEiByte = (&big.Int{}).Mul(BigPiByte, bigIECExp)
    // BigZiByte is 1,024 e bytes in bit.Ints
    BigZiByte = (&big.Int{}).Mul(BigEiByte, bigIECExp)
    // BigYiByte is 1,024 z bytes in bit.Ints
    BigYiByte = (&big.Int{}).Mul(BigZiByte, bigIECExp)
)
```

<a name="BigSIByte"></a>

```go
var (

    // BigSIByte is one SI byte in big.Ints
    BigSIByte = big.NewInt(1)
    // BigKByte is 1,000 SI bytes in big.Ints
    BigKByte = (&big.Int{}).Mul(BigSIByte, bigSIExp)
    // BigMByte is 1,000 SI k bytes in big.Ints
    BigMByte = (&big.Int{}).Mul(BigKByte, bigSIExp)
    // BigGByte is 1,000 SI m bytes in big.Ints
    BigGByte = (&big.Int{}).Mul(BigMByte, bigSIExp)
    // BigTByte is 1,000 SI g bytes in big.Ints
    BigTByte = (&big.Int{}).Mul(BigGByte, bigSIExp)
    // BigPByte is 1,000 SI t bytes in big.Ints
    BigPByte = (&big.Int{}).Mul(BigTByte, bigSIExp)
    // BigEByte is 1,000 SI p bytes in big.Ints
    BigEByte = (&big.Int{}).Mul(BigPByte, bigSIExp)
    // BigZByte is 1,000 SI e bytes in big.Ints
    BigZByte = (&big.Int{}).Mul(BigEByte, bigSIExp)
    // BigYByte is 1,000 SI z bytes in big.Ints
    BigYByte = (&big.Int{}).Mul(BigZByte, bigSIExp)
)
```

<a name="Rand"></a>

```go
var (
    // Rand goroutine-safe, use Rand.xxx instead of rand.xxx
    Rand = NewRand()
    Seed = FastRand()
)
```

<a name="ErrInvalidHostPort"></a>

```go
var ErrInvalidHostPort = errors.New("invalid Host or Port")
```

<a name="StackTraceBufferSize"></a>

```go
var StackTraceBufferSize = 4 << 10
```

<a name="B2S"></a>
## func B2S

```go
func B2S(b []byte) string
```

B2S converts byte slice to string without a memory allocation. Slower: unsafe.String\(unsafe.SliceData\(b\), len\(b\)\) strings.Clone\(\): unsafe.String\(&b\[0\], len\(b\)\)

<a name="B64Decode"></a>
## func B64Decode

```go
func B64Decode(s string) []byte
```

B64Decode Base64 解码

<a name="B64Encode"></a>
## func B64Encode

```go
func B64Encode(b []byte) string
```

B64Encode Base64 编码

<a name="B64UrlDecode"></a>
## func B64UrlDecode

```go
func B64UrlDecode(s string) []byte
```

B64UrlDecode Base64 解码

<a name="B64UrlEncode"></a>
## func B64UrlEncode

```go
func B64UrlEncode(b []byte) string
```

B64UrlEncode Base64 解码, 安全 URL, 替换: "\+/" 为 "\-\_"

<a name="BeginOfDay"></a>
## func BeginOfDay

```go
func BeginOfDay(t time.Time) time.Time
```

BeginOfDay 当天 0 点

<a name="BeginOfHour"></a>
## func BeginOfHour

```go
func BeginOfHour(t time.Time) time.Time
```

BeginOfHour 0 分

<a name="BeginOfLastMonth"></a>
## func BeginOfLastMonth

```go
func BeginOfLastMonth(t time.Time) time.Time
```

BeginOfLastMonth 上月第一天 0 点

<a name="BeginOfLastWeek"></a>
## func BeginOfLastWeek

```go
func BeginOfLastWeek(t time.Time) time.Time
```

BeginOfLastWeek 上周一 0 点

<a name="BeginOfMinute"></a>
## func BeginOfMinute

```go
func BeginOfMinute(t time.Time) time.Time
```

BeginOfMinute 0 秒

<a name="BeginOfMonth"></a>
## func BeginOfMonth

```go
func BeginOfMonth(t time.Time) time.Time
```

BeginOfMonth 当月第一天 0 点

<a name="BeginOfNextMonth"></a>
## func BeginOfNextMonth

```go
func BeginOfNextMonth(t time.Time) time.Time
```

BeginOfNextMonth 下月第一天 0 点

<a name="BeginOfNextWeek"></a>
## func BeginOfNextWeek

```go
func BeginOfNextWeek(t time.Time) time.Time
```

BeginOfNextWeek 下周一 0 点

<a name="BeginOfSecond"></a>
## func BeginOfSecond

```go
func BeginOfSecond(t time.Time) time.Time
```

BeginOfSecond 0 毫秒

<a name="BeginOfTomorrow"></a>
## func BeginOfTomorrow

```go
func BeginOfTomorrow(t time.Time) time.Time
```

BeginOfTomorrow 明天 0 点

<a name="BeginOfWeek"></a>
## func BeginOfWeek

```go
func BeginOfWeek(t time.Time) time.Time
```

BeginOfWeek 本周一 0 点

<a name="BeginOfYear"></a>
## func BeginOfYear

```go
func BeginOfYear(t time.Time) time.Time
```

BeginOfYear 本年第一天 0 点

<a name="BeginOfYesterday"></a>
## func BeginOfYesterday

```go
func BeginOfYesterday(t time.Time) time.Time
```

BeginOfYesterday 昨天 0 点

<a name="BigComma"></a>
## func BigComma

```go
func BigComma(b *big.Int) string
```

BigComma big.Int 千分位分隔字符串 Ref: dustin/go\-humanize

<a name="BigCommaf"></a>
## func BigCommaf

```go
func BigCommaf(v *big.Float) string
```

BigCommaf big.Float 千分位分隔字符串 Ref: dustin/go\-humanize

<a name="Bigoom"></a>
## func Bigoom

```go
func Bigoom(n, b *big.Int) (float64, int)
```

Bigoom big.Int 总数量级 Ref: dustin/go\-humanize

<a name="CPUTicks"></a>
## func CPUTicks

```go
func CPUTicks() int64
```

CPUTicks CPU 时钟周期, 更高精度 \(云服务器做伪随机数种子时慎用\)

<a name="CallPath"></a>
## func CallPath

```go
func CallPath() string
```

CallPath 运行时路径, 编译目录 假如: mklink E:\\tmp\\linkapp.exe D:\\Fufu\\Test\\abc\\app.exe 执行: E:\\tmp\\linkapp.exe CallPath: E:\\Go\\src\\github.com\\fufuok\\utils\\tmp\\osext

<a name="CheckDomain"></a>
## func CheckDomain

```go
func CheckDomain(name string) error
```

CheckDomain returns an error if the host name is not valid. See https://tools.ietf.org/html/rfc1034#section-3.5 and https://tools.ietf.org/html/rfc1123#section-2. Ref: chmike/domain

<a name="Comma"></a>
## func Comma

```go
func Comma(v int64) string
```

Comma 整数转千分位分隔字符串 Ref: dustin/go\-humanize e.g. Comma\(834142\) \-\> 834,142

<a name="Commaf"></a>
## func Commaf

```go
func Commaf(v float64) string
```

Commaf 浮点数转千分位分隔字符串 Ref: dustin/go\-humanize e.g. Commaf\(834142.32\) \-\> 834,142.32

<a name="Commai"></a>
## func Commai

```go
func Commai(v int) string
```

Commai 整数转千分位分隔字符串

<a name="Commau"></a>
## func Commau

```go
func Commau(v uint64) string
```

Commau 整数转千分位分隔字符串 Ref: dustin/go\-humanize

<a name="CopyB2S"></a>
## func CopyB2S

```go
func CopyB2S(b []byte) string
```

CopyB2S Immutable, \[\]byte to string string\(b\)

<a name="CopyBytes"></a>
## func CopyBytes

```go
func CopyBytes(b []byte) []byte
```

CopyBytes Immutable, \[\]byte to \[\]byte

<a name="CopyS2B"></a>
## func CopyS2B

```go
func CopyS2B(s string) []byte
```

CopyS2B Immutable, string to \[\]byte \[\]byte\(s\)

<a name="CopyString"></a>
## func CopyString

```go
func CopyString(s string) string
```

CopyString Immutable, string to string e.g. fiberParam := utils.CopyString\(c.Params\("test"\)\) e.g. utils.CopyString\(s\[500:1000\]\) // 可以让 s 被 GC 回收 strings.Clone\(s\) // go1.18

<a name="CutBytes"></a>
## func CutBytes

```go
func CutBytes(s, sep []byte) (before, after []byte, found bool)
```

CutBytes slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, nil, false.

Cut returns slices of the original slice s, not copies. Ref: go1.18

<a name="CutString"></a>
## func CutString

```go
func CutString(s, sep string) (before, after string, found bool)
```

CutString xslices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, "", false. Ref: go1.18

<a name="DaysInMonth"></a>
## func DaysInMonth

```go
func DaysInMonth(year int, m time.Month) int
```

DaysInMonth 返回月份天数

<a name="DaysInYear"></a>
## func DaysInYear

```go
func DaysInYear(year int) int
```

DaysInYear 返回年份天数

<a name="EncodeUUID"></a>
## func EncodeUUID

```go
func EncodeUUID(id []byte) []byte
```

EncodeUUID 编码 UUID

<a name="EndOfDay"></a>
## func EndOfDay

```go
func EndOfDay(t time.Time) time.Time
```

EndOfDay 当天最后时刻

<a name="EndOfHour"></a>
## func EndOfHour

```go
func EndOfHour(t time.Time) time.Time
```

EndOfHour 最后一分

<a name="EndOfLastMonth"></a>
## func EndOfLastMonth

```go
func EndOfLastMonth(t time.Time) time.Time
```

EndOfLastMonth 上月最后一刻

<a name="EndOfLastWeek"></a>
## func EndOfLastWeek

```go
func EndOfLastWeek(t time.Time) time.Time
```

EndOfLastWeek 上周一最后一刻

<a name="EndOfMinute"></a>
## func EndOfMinute

```go
func EndOfMinute(t time.Time) time.Time
```

EndOfMinute 最后一秒

<a name="EndOfMonth"></a>
## func EndOfMonth

```go
func EndOfMonth(t time.Time) time.Time
```

EndOfMonth 当月最后一刻

<a name="EndOfNextMonth"></a>
## func EndOfNextMonth

```go
func EndOfNextMonth(t time.Time) time.Time
```

EndOfNextMonth 下月最后一刻

<a name="EndOfNextWeek"></a>
## func EndOfNextWeek

```go
func EndOfNextWeek(t time.Time) time.Time
```

EndOfNextWeek 下周一最后一刻

<a name="EndOfSecond"></a>
## func EndOfSecond

```go
func EndOfSecond(t time.Time) time.Time
```

EndOfSecond 最后一毫秒

<a name="EndOfTomorrow"></a>
## func EndOfTomorrow

```go
func EndOfTomorrow(t time.Time) time.Time
```

EndOfTomorrow 明天 0 点

<a name="EndOfWeek"></a>
## func EndOfWeek

```go
func EndOfWeek(t time.Time) time.Time
```

EndOfWeek 本周末最后一刻

<a name="EndOfYear"></a>
## func EndOfYear

```go
func EndOfYear(t time.Time) time.Time
```

EndOfYear 本年最后一刻

<a name="EndOfYesterday"></a>
## func EndOfYesterday

```go
func EndOfYesterday(t time.Time) time.Time
```

EndOfYesterday 昨天最后时刻

<a name="EqualFold"></a>
## func EqualFold

```go
func EqualFold(b, s string) bool
```

EqualFold tests ascii strings for equality case\-insensitively Ref: fiber

<a name="EqualFoldBytes"></a>
## func EqualFoldBytes

```go
func EqualFoldBytes(b, s []byte) bool
```

EqualFoldBytes tests ascii slices for equality case\-insensitively Ref: fiber

<a name="Executable"></a>
## func Executable

```go
func Executable(evalSymlinks ...bool) string
```

Executable 当前执行程序绝对路径 true 时返回解析符号链接后的绝对路径 Excutable: E:\\tmp\\linkapp.exe Excutable\(true\): D:\\Fufu\\Test\\abc\\app.exe

<a name="ExecutableDir"></a>
## func ExecutableDir

```go
func ExecutableDir(evalSymlinks ...bool) string
```

ExecutableDir 当前执行程序所在目录 true 时返回解析符号链接后的目录 ExcutableDir: E:\\tmp ExcutableDir\(true\): D:\\Fufu\\Test\\abc

<a name="FastIntn"></a>
## func FastIntn

```go
func FastIntn(n int) int
```

FastIntn this is similar to rand.Intn, but faster. A non\-negative pseudo\-random number in the half\-open interval \[0,n\). Return 0 if n \<= 0.

<a name="FastRand"></a>
## func FastRand

```go
func FastRand() uint32
```

FastRand 随机数

<a name="FastRand64"></a>
## func FastRand64

```go
func FastRand64() uint64
```



<a name="FastRandn"></a>
## func FastRandn

```go
func FastRandn(n uint32) uint32
```

FastRandn 等同于 FastRand\(\) % n, 但更快 See https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/

<a name="FastRandu"></a>
## func FastRandu

```go
func FastRandu() uint
```



<a name="FirstString"></a>
## func FirstString

```go
func FirstString(s, sep string, defaultStr ...string) string
```

FirstString 获取文本内容第一个分隔符\(单字节: sep\[0\]\)前的内容

<a name="GetBytes"></a>
## func GetBytes

```go
func GetBytes(v interface{}, defaultVal ...[]byte) []byte
```

GetBytes 先转为字符串再转为 \[\]byte, 可选指定默认值

<a name="GetDomain"></a>
## func GetDomain

```go
func GetDomain(name string) string
```

GetDomain 检查并返回清除前后空白的域名

<a name="GetIPPort"></a>
## func GetIPPort

```go
func GetIPPort(addr net.Addr) (ip net.IP, port int, err error)
```

GetIPPort 返回 IP 和 端口

<a name="GetInt"></a>
## func GetInt

```go
func GetInt(v interface{}, defaultInt ...int) int
```

GetInt 获取 int 结果, 可选指定默认值\(若给定了默认值,则返回正整数或 0\)

<a name="GetMonthDays"></a>
## func GetMonthDays

```go
func GetMonthDays(t time.Time) int
```

GetMonthDays 当月天数

<a name="GetNotInternalIPv4"></a>
## func GetNotInternalIPv4

```go
func GetNotInternalIPv4(ip, defaultIP net.IP, flag ...bool) net.IP
```

GetNotInternalIPv4 如果是内网 IPv4 则使用默认值, flag 为真是必定返回一个 IP

<a name="GetNotInternalIPv4String"></a>
## func GetNotInternalIPv4String

```go
func GetNotInternalIPv4String(ip, defaultIP string, flag ...bool) string
```

GetNotInternalIPv4String 如果是内网 IPv4 则使用默认值

<a name="GetSafeB2S"></a>
## func GetSafeB2S

```go
func GetSafeB2S(b []byte, defaultVal ...string) string
```

GetSafeB2S Immutable, 可选指定默认值

<a name="GetSafeBytes"></a>
## func GetSafeBytes

```go
func GetSafeBytes(b []byte, defaultVal ...[]byte) []byte
```

GetSafeBytes Immutable, 可选指定默认值

<a name="GetSafeS2B"></a>
## func GetSafeS2B

```go
func GetSafeS2B(s string, defaultVal ...[]byte) []byte
```

GetSafeS2B Immutable, 可选指定默认值

<a name="GetSafeString"></a>
## func GetSafeString

```go
func GetSafeString(s string, defaultVal ...string) string
```

GetSafeString Immutable, 可选指定默认值

<a name="GetString"></a>
## func GetString

```go
func GetString(v interface{}, defaultVal ...string) string
```

GetString 获取字符串结果, 可选指定默认值

<a name="GoroutineID"></a>
## func GoroutineID

```go
func GoroutineID() (uint64, error)
```

GoroutineID 获取 Goroutine ID

<a name="Gzip"></a>
## func Gzip

```go
func Gzip(data []byte) ([]byte, error)
```



<a name="GzipLevel"></a>
## func GzipLevel

```go
func GzipLevel(data []byte, level int) (dst []byte, err error)
```



<a name="HumanBaseBytes"></a>
## func HumanBaseBytes

```go
func HumanBaseBytes(v uint64, base float64, sizes []string) string
```

HumanBaseBytes 数字的数量级表示

<a name="HumanBigBytes"></a>
## func HumanBigBytes

```go
func HumanBigBytes(s *big.Int) string
```

HumanBigBytes produces a human readable representation of an SI size.

See also: ParseHumanBigBytes.

HumanBigBytes\(82854982\) \-\> 83 MB

<a name="HumanBigIBytes"></a>
## func HumanBigIBytes

```go
func HumanBigIBytes(s *big.Int) string
```

HumanBigIBytes produces a human readable representation of an IEC size.

See also: ParseHumanBigBytes.

HumanBigIBytes\(82854982\) \-\> 79 MiB

<a name="HumanBigKbps"></a>
## func HumanBigKbps

```go
func HumanBigKbps(s *big.Int) string
```

HumanBigKbps 1 Kbps = 1000 bit, 传输速率\(bit per second, 位每秒\) e.g. HumanBigKbps\(82854982\) \-\> 83 Mbps

<a name="HumanBytes"></a>
## func HumanBytes

```go
func HumanBytes(v uint64) string
```

HumanBytes 1 KB = 1000 B e.g. HumanBytes\(82854982\) \-\> 83 MB

<a name="HumanGBMB"></a>
## func HumanGBMB

```go
func HumanGBMB(v uint64) string
```

HumanGBMB 转为 \*\* GB \*\* MB 1 GB = 1024 MB

<a name="HumanIBytes"></a>
## func HumanIBytes

```go
func HumanIBytes(v uint64) string
```

HumanIBytes 1 KiB = 1024 B e.g. HumanIBytes\(82854982\) \-\> 79 MiB

<a name="HumanIntBytes"></a>
## func HumanIntBytes

```go
func HumanIntBytes(v int) string
```

HumanIntBytes 1 KB = 1000 B

<a name="HumanIntIBytes"></a>
## func HumanIntIBytes

```go
func HumanIntIBytes(v int) string
```

HumanIntIBytes 1 KiB = 1024 B

<a name="HumanIntKbps"></a>
## func HumanIntKbps

```go
func HumanIntKbps(v int) string
```

HumanIntKbps 1 Kbps = 1000 bit

<a name="HumanKbps"></a>
## func HumanKbps

```go
func HumanKbps(v uint64) string
```

HumanKbps 1 Kbps = 1000 bit, 传输速率\(bit per second, 位每秒\) e.g. HumanKbps\(82854982\) \-\> 83 Mbps

<a name="ID"></a>
## func ID

```go
func ID() uint64
```

ID 运行时自增 ID \(每次程序启动从 1 开始\)

<a name="IPv42Long"></a>
## func IPv42Long

```go
func IPv42Long(ip net.IP) int
```

IPv42Long IPv4 转数值

<a name="IPv42LongLittle"></a>
## func IPv42LongLittle

```go
func IPv42LongLittle(ip net.IP) int
```

IPv42LongLittle IPv4 转小端数值

<a name="IPv4String2Long"></a>
## func IPv4String2Long

```go
func IPv4String2Long(ip string) int
```

IPv4String2Long IPv4 字符串转数值

<a name="IPv4String2LongLittle"></a>
## func IPv4String2LongLittle

```go
func IPv4String2LongLittle(ip string) int
```

IPv4String2LongLittle IPv4 字符串转数值\(小端\)

<a name="IPv62Int"></a>
## func IPv62Int

```go
func IPv62Int(ip net.IP) *big.Int
```

IPv62Int IPv6 转数值

<a name="IPv6String2Int"></a>
## func IPv6String2Int

```go
func IPv6String2Int(ip string) *big.Int
```

IPv6String2Int IPv6 字符串转数值

<a name="InIPNet"></a>
## func InIPNet

```go
func InIPNet(ip net.IP, ipNets map[*net.IPNet]struct{}) bool
```

InIPNet 是否包含在指定 IPNet 列表中

<a name="InIPNetString"></a>
## func InIPNetString

```go
func InIPNetString(ip string, ipNets map[*net.IPNet]struct{}) bool
```

InIPNetString 是否包含在指定 IPNet 列表中

<a name="InInts"></a>
## func InInts

```go
func InInts(slice []int, n int) bool
```

InInts 检查整数是否存在于 slice

<a name="InStrings"></a>
## func InStrings

```go
func InStrings(ss []string, s string) bool
```

InStrings 检查字符串是否存在于 slice 用 slices.Contains 替代

<a name="InitCSTLocation"></a>
## func InitCSTLocation

```go
func InitCSTLocation() (name string, loc *time.Location, cst *time.Location, ok bool)
```

InitCSTLocation 初始化默认时区为中国东八区\(GMT\+8\) 返回值: name: "Asia/Shanghai" 或本地时区名称 loc: 优先尝试解析中国时区, 失败\(Windows\)后使用本地时区\(time.Local\) cst: 强制偏移的中国时区, \!\!\!注意: 无法使用 time.LoadLocation\(cst.String\(\)\) 二次加载 ok: true 表示初始化中国时区成功, false 表示 local 不一定是中国时区

<a name="InitLocation"></a>
## func InitLocation

```go
func InitLocation(name string) (*time.Location, bool)
```

InitLocation 解析并初始化本地时区

<a name="Int2IPv6"></a>
## func Int2IPv6

```go
func Int2IPv6(ipInt *big.Int) net.IP
```

Int2IPv6 数值转 IPv4

<a name="Int2IPv6String"></a>
## func Int2IPv6String

```go
func Int2IPv6String(n *big.Int) string
```

Int2IPv6String 数值转 IPv6 字符串

<a name="IsIP"></a>
## func IsIP

```go
func IsIP(ip string) bool
```

IsIP 判断是否为合法 IPv4 / IPv6

<a name="IsIPv4"></a>
## func IsIPv4

```go
func IsIPv4(s string) bool
```

IsIPv4 判断是否为合法 IPv4 IsIPv4 works the same way as net.ParseIP, but without check for IPv6 case and without returning net.IP slice, whereby IsIPv4 makes no allocations. Ref: gofiber/utils

<a name="IsIPv6"></a>
## func IsIPv6

```go
func IsIPv6(s string) bool
```

IsIPv6 判断是否为合法 IPv6 IsIPv6 works the same way as net.ParseIP, but without check for IPv4 case and without returning net.IP slice, whereby IsIPv6 makes no allocations. Ref: gofiber/utils

<a name="IsInternalIPv4"></a>
## func IsInternalIPv4

```go
func IsInternalIPv4(ip net.IP) bool
```

IsInternalIPv4 是否为内网 IPv4, 包含 NAT 专用网段 RFC6598, 比如华为云 ELB 的 100.125.0.0/16

<a name="IsInternalIPv4String"></a>
## func IsInternalIPv4String

```go
func IsInternalIPv4String(ip string) bool
```

IsInternalIPv4String 是否为内网 IPv4

<a name="IsLeapYear"></a>
## func IsLeapYear

```go
func IsLeapYear(year int) bool
```

IsLeapYear 判断是否为闰年

<a name="IsLetter"></a>
## func IsLetter

```go
func IsLetter(s string) bool
```

IsLetter 检查字符串是否全是 ASCII 字母

<a name="IsLetterOrNumeric"></a>
## func IsLetterOrNumeric

```go
func IsLetterOrNumeric(s string) bool
```

IsLetterOrNumeric 检查字符串是否全是 ASCII 字母或数字

<a name="IsNumeric"></a>
## func IsNumeric

```go
func IsNumeric(s string) bool
```

IsNumeric 检查字符串是否全是 ASCII 数字: 0\-9

<a name="IsPrivateIP"></a>
## func IsPrivateIP

```go
func IsPrivateIP(ip net.IP) bool
```

IsPrivateIP reports whether ip is a private address, according to RFC 1918 \(IPv4 addresses\) and RFC 4193 \(IPv6 addresses\). Ref: go1.17\+ func \(ip IP\) IsPrivate\(\) bool

<a name="IsPrivateIPString"></a>
## func IsPrivateIPString

```go
func IsPrivateIPString(ip string) bool
```

IsPrivateIPString 是否为私有 IP

<a name="JoinBytes"></a>
## func JoinBytes

```go
func JoinBytes(b ...[]byte) []byte
```

JoinBytes 拼接 \[\]byte

<a name="JoinString"></a>
## func JoinString

```go
func JoinString(s ...string) string
```

JoinString 拼接字符串

<a name="JoinStringBytes"></a>
## func JoinStringBytes

```go
func JoinStringBytes(s ...string) []byte
```

JoinStringBytes 拼接字符串, 返回 bytes from bytes.Join\(\)

<a name="LastString"></a>
## func LastString

```go
func LastString(s, sep string, defaultStr ...string) string
```

LastString 获取文本内容最后一个分隔符\(单字节: sep\[0\]\)后的内容

<a name="LeftPad"></a>
## func LeftPad

```go
func LeftPad(s, pad string, n int) string
```

LeftPad 从左填充字符串到指定长度

<a name="LeftPadBytes"></a>
## func LeftPadBytes

```go
func LeftPadBytes(b, pad []byte, n int) []byte
```

LeftPadBytes 从左填充到指定长度

<a name="Logn"></a>
## func Logn

```go
func Logn(n, b float64) float64
```



<a name="Long2IPv4"></a>
## func Long2IPv4

```go
func Long2IPv4(n int) net.IP
```

Long2IPv4 数值转 IPv4

<a name="Long2IPv4String"></a>
## func Long2IPv4String

```go
func Long2IPv4String(n int) string
```

Long2IPv4String 数值转 IPv4 字符串

<a name="LongLittle2IPv4"></a>
## func LongLittle2IPv4

```go
func LongLittle2IPv4(n int) net.IP
```

LongLittle2IPv4 小端数值转 IPv4

<a name="LongLittle2IPv4String"></a>
## func LongLittle2IPv4String

```go
func LongLittle2IPv4String(n int) string
```

LongLittle2IPv4String 数值\(小端\)转 IPv4 字符串

<a name="MaxInt"></a>
## func MaxInt

```go
func MaxInt(a, b int) int
```

MaxInt 整数取大值

<a name="MinInt"></a>
## func MinInt

```go
func MinInt(a, b int) int
```

MinInt 整数取小值

<a name="MustBool"></a>
## func MustBool

```go
func MustBool(v interface{}) bool
```

MustBool 强制转为 bool

<a name="MustInt"></a>
## func MustInt

```go
func MustInt(v interface{}) int
```

MustInt 强制转为整数 \(int\)

<a name="MustJSON"></a>
## func MustJSON

```go
func MustJSON(v interface{}) []byte
```

MustJSON 转 json 返回 \[\]byte

<a name="MustJSONIndent"></a>
## func MustJSONIndent

```go
func MustJSONIndent(v interface{}) []byte
```

MustJSONIndent 转 json 返回 \[\]byte

<a name="MustJSONIndentString"></a>
## func MustJSONIndentString

```go
func MustJSONIndentString(v interface{}) string
```

MustJSONIndentString 转 json Indent 返回 string

<a name="MustJSONString"></a>
## func MustJSONString

```go
func MustJSONString(v interface{}) string
```

MustJSONString 转 json 返回 string

<a name="MustParseHumanBigBytes"></a>
## func MustParseHumanBigBytes

```go
func MustParseHumanBigBytes(s string, defaultVal ...*big.Int) *big.Int
```

MustParseHumanBigBytes 解析数字的数量级表示 e.g. MustParseHumanBigBytes\("42 MB"\) \-\> 42000000 e.g. MustParseHumanBigBytes\("\-42 mib", 123\) \-\> 123

<a name="MustParseHumanBytes"></a>
## func MustParseHumanBytes

```go
func MustParseHumanBytes(s string, defaultVal ...uint64) uint64
```

MustParseHumanBytes 解析数字的数量级表示 e.g. MustParseHumanBytes\("42 MB"\) \-\> 42000000 e.g. MustParseHumanBytes\("\-42 mib", 123\) \-\> 123

<a name="MustString"></a>
## func MustString

```go
func MustString(v interface{}, timeLayout ...string) string
```

MustString 强制转为字符串

<a name="NanoTime"></a>
## func NanoTime

```go
func NanoTime() int64
```

NanoTime 返回当前时间 \(以纳秒为单位\)

<a name="NewRand"></a>
## func NewRand

```go
func NewRand(seed ...int64) *rand.Rand
```

NewRand goroutine\-safe rand.Rand, optional seed value

<a name="Pad"></a>
## func Pad

```go
func Pad(s, pad string, n int) string
```

Pad 填充字符串到指定长度, 同 Python3: 'str'.center\(\)

<a name="PadBytes"></a>
## func PadBytes

```go
func PadBytes(s, pad []byte, n int) []byte
```

PadBytes 填充到指定长度

<a name="ParseHostPort"></a>
## func ParseHostPort

```go
func ParseHostPort(s string) (net.IP, uint16, bool, error)
```

ParseHostPort 解析 IP 和端口

<a name="ParseHumanBigBytes"></a>
## func ParseHumanBigBytes

```go
func ParseHumanBigBytes(s string) (*big.Int, error)
```

ParseHumanBigBytes parses a string representation of bytes into the number of bytes it represents.

See also: HumanBigBytes, HumanBigIBytes.

ParseHumanBigBytes\("42 MB"\) \-\> 42000000, nil ParseHumanBigBytes\("42 mib"\) \-\> 44040192, nil

<a name="ParseHumanBytes"></a>
## func ParseHumanBytes

```go
func ParseHumanBytes(s string) (uint64, error)
```

ParseHumanBytes 解析数字的数量级表示 e.g. ParseHumanBytes\("42 MB"\) \-\> 42000000, nil e.g. ParseHumanBytes\("42 mib"\) \-\> 44040192, nil

<a name="ParseIP"></a>
## func ParseIP

```go
func ParseIP(s string) (net.IP, bool)
```

ParseIP 解析 IP 并返回是否为 IPv6

<a name="ParseIPv4"></a>
## func ParseIPv4

```go
func ParseIPv4(ip string) net.IP
```

ParseIPv4 判断是否为合法 IPv4 并解析

<a name="ParseIPv6"></a>
## func ParseIPv6

```go
func ParseIPv6(ip string) net.IP
```

ParseIPv6 判断是否为合法 IPv6 并解析

<a name="ParseIPx"></a>
## func ParseIPx

```go
func ParseIPx(s string) (net.IP, bool)
```

ParseIPx 解析 IP, 并返回是否为 IPv6

<a name="ParseIPxWithNumeric"></a>
## func ParseIPxWithNumeric

```go
func ParseIPxWithNumeric(s string) (net.IP, bool)
```

ParseIPxWithNumeric 解析 IP, 支持数字形态, 并返回是否为 IPv6

<a name="ParseInts"></a>
## func ParseInts

```go
func ParseInts(s string) ([]int, error)
```

ParseInts 解析字符串, 得到去重并排序后的数字列表 "5,0\-3, 3" =\> \[0,1,2,3,5\]

<a name="RandAlphaBytes"></a>
## func RandAlphaBytes

```go
func RandAlphaBytes(n int) []byte
```

RandAlphaBytes generates random alpha bytes.

<a name="RandAlphaString"></a>
## func RandAlphaString

```go
func RandAlphaString(n int) string
```

RandAlphaString 指定长度的随机字母字符串

<a name="RandBytes"></a>
## func RandBytes

```go
func RandBytes(n int) []byte
```

RandBytes random bytes, but faster.

<a name="RandBytesLetters"></a>
## func RandBytesLetters

```go
func RandBytesLetters(n int, letters string) []byte
```

RandBytesLetters 生成指定长度的字符切片

<a name="RandDecBytes"></a>
## func RandDecBytes

```go
func RandDecBytes(n int) []byte
```

RandDecBytes 指定长度的随机数字切片

<a name="RandDecString"></a>
## func RandDecString

```go
func RandDecString(n int) string
```

RandDecString 指定长度的随机数字字符串

<a name="RandHexBytes"></a>
## func RandHexBytes

```go
func RandHexBytes(n int) []byte
```

RandHexBytes generates random hexadecimal bytes.

<a name="RandHexString"></a>
## func RandHexString

```go
func RandHexString(n int) string
```

RandHexString 指定长度的随机 hex 字符串

<a name="RandInt"></a>
## func RandInt

```go
func RandInt(min, max int) int
```

RandInt \(\>=\)min \- \(\<\)max

<a name="RandString"></a>
## func RandString

```go
func RandString(n int) string
```

RandString a random string, which may contain uppercase letters, lowercase letters and numbers. Ref: stackoverflow.icza

<a name="RandUint32"></a>
## func RandUint32

```go
func RandUint32(min, max uint32) uint32
```

RandUint32 \(\>=\)min \- \(\<\)max

<a name="Recover"></a>
## func Recover

```go
func Recover(cb ...RecoveryCallback)
```

Recover 从 panic 中恢复并记录堆栈信息

<a name="RemoveString"></a>
## func RemoveString

```go
func RemoveString(ss []string, s string) ([]string, bool)
```

RemoveString 删除字符串元素

<a name="ReplaceHost"></a>
## func ReplaceHost

```go
func ReplaceHost(a, b string) string
```

ReplaceHost 返回 b 的主机名 \+ a 的端口 e.g. ReplaceHost\("a.cn:77", "b.cn:88"\) == "b.cn:77"

<a name="Reverse"></a>
## func Reverse

```go
func Reverse(s string) string
```

Reverse 反转字符串

<a name="RightPad"></a>
## func RightPad

```go
func RightPad(s, pad string, n int) string
```

RightPad 从右填充字符串到指定长度

<a name="RightPadBytes"></a>
## func RightPadBytes

```go
func RightPadBytes(b, pad []byte, n int) []byte
```

RightPadBytes 从右填充到指定长度

<a name="Round"></a>
## func Round

```go
func Round(v float64, precision int) float64
```

Round 四舍五入, ROUND\_HALF\_UP 模式实现 返回将 val 根据指定精度 precision \(十进制小数点后数字的数目\) 进行四舍五入的结果 precision 也可以是负数或零 Ref: thinkeridea/go\-extend

<a name="RunPath"></a>
## func RunPath

```go
func RunPath() string
```

RunPath 实际程序所在目录 RunPath: E:\\tmp

<a name="RuneReverse"></a>
## func RuneReverse

```go
func RuneReverse(s string) string
```

RuneReverse 反转多字节字符串

<a name="RuneSubString"></a>
## func RuneSubString

```go
func RuneSubString(s string, length int, suffix string) string
```

RuneSubString 多字节字符串截取 长度支持 0\(空字符串\) / \>0\(正常截取\) / \<0\(从结尾处往前截取\) 长度等于或超过字符串长度, 返回原字符串值, 此时忽略 suffix 参数

<a name="S2B"></a>
## func S2B

```go
func S2B(s string) []byte
```

S2B converts string to byte slice without a memory allocation. Ref: https://github.com/golang/go/issues/53003#issuecomment-1140276077

<a name="SafeGo"></a>
## func SafeGo

```go
func SafeGo(fn func(), cb ...RecoveryCallback)
```

SafeGo 带 Recover 的 goroutine 运行

<a name="SafeGoCommonFunc"></a>
## func SafeGoCommonFunc

```go
func SafeGoCommonFunc(args interface{}, fn func(args interface{}), cb ...RecoveryCallback)
```

SafeGoCommonFunc 带 Recover 的 goroutine 运行

<a name="SafeGoWithContext"></a>
## func SafeGoWithContext

```go
func SafeGoWithContext(ctx context.Context, fn func(ctx context.Context), cb ...RecoveryCallback)
```

SafeGoWithContext 带 Recover 的 goroutine 运行

<a name="SearchInt"></a>
## func SearchInt

```go
func SearchInt(slice []int, n int) int
```

SearchInt 搜索整数位置\(左, 第一个\)

<a name="SearchString"></a>
## func SearchString

```go
func SearchString(ss []string, s string) int
```

SearchString 搜索字符串位置\(左, 第一个\) 用 slices.Index 替代

<a name="Sleep"></a>
## func Sleep

```go
func Sleep(ctx context.Context, interval time.Duration) error
```

Sleep 支持上下文中断的 time.Sleep

<a name="SplitHostPort"></a>
## func SplitHostPort

```go
func SplitHostPort(hostPort string) (host, port string)
```

SplitHostPort separates host and port. If the port is not valid, it returns the entire input as host, and it doesn't check the validity of the host. Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.

<a name="SumInt"></a>
## func SumInt

```go
func SumInt(v ...int) int
```

SumInt 整数和

<a name="ToLower"></a>
## func ToLower

```go
func ToLower(b string) string
```

ToLower converts ascii string to lower\-case Ref: fiber

<a name="ToLowerBytes"></a>
## func ToLowerBytes

```go
func ToLowerBytes(b []byte) []byte
```

ToLowerBytes converts ascii slice to lower\-case Ref: fiber

<a name="ToUpper"></a>
## func ToUpper

```go
func ToUpper(b string) string
```

ToUpper converts ascii string to upper\-case Ref: fiber

<a name="ToUpperBytes"></a>
## func ToUpperBytes

```go
func ToUpperBytes(b []byte) []byte
```

ToUpperBytes converts ascii slice to upper\-case Ref: fiber

<a name="Trim"></a>
## func Trim

```go
func Trim(s string, cutset byte) string
```

Trim is the equivalent of strings.Trim Ref: fiber

<a name="TrimBytes"></a>
## func TrimBytes

```go
func TrimBytes(b []byte, cutset byte) []byte
```

TrimBytes is the equivalent of bytes.Trim Ref: fiber

<a name="TrimLeft"></a>
## func TrimLeft

```go
func TrimLeft(s string, cutset byte) string
```

TrimLeft is the equivalent of strings.TrimLeft Ref: fiber

<a name="TrimLeftBytes"></a>
## func TrimLeftBytes

```go
func TrimLeftBytes(b []byte, cutset byte) []byte
```

TrimLeftBytes is the equivalent of bytes.TrimLeft Ref: fiber

<a name="TrimRight"></a>
## func TrimRight

```go
func TrimRight(s string, cutset byte) string
```

TrimRight is the equivalent of strings.TrimRight Ref: fiber

<a name="TrimRightBytes"></a>
## func TrimRightBytes

```go
func TrimRightBytes(b []byte, cutset byte) []byte
```

TrimRightBytes is the equivalent of bytes.TrimRight Ref: fiber

<a name="TrimSlice"></a>
## func TrimSlice

```go
func TrimSlice(ss []string) []string
```

TrimSlice 清除 slice 中各元素的空白, 并删除空白项 注意: 原切片将被修改

<a name="TruncStr"></a>
## func TruncStr

```go
func TruncStr(s string, maxLen int, suffix string) string
```

TruncStr 截断字符串

<a name="UUID"></a>
## func UUID

```go
func UUID() []byte
```

UUID 随机 UUID, RFC4122, Version 4

<a name="UUIDShort"></a>
## func UUIDShort

```go
func UUIDShort() string
```

UUIDShort 随机 UUID, 短版, base58

<a name="UUIDSimple"></a>
## func UUIDSimple

```go
func UUIDSimple() string
```

UUIDSimple 随机 UUID, 无短横线

<a name="UUIDString"></a>
## func UUIDString

```go
func UUIDString() string
```

UUIDString 随机 UUID

<a name="Ungzip"></a>
## func Ungzip

```go
func Ungzip(data []byte) (src []byte, err error)
```



<a name="Unzip"></a>
## func Unzip

```go
func Unzip(data []byte) (src []byte, err error)
```



<a name="ValidOptionalPort"></a>
## func ValidOptionalPort

```go
func ValidOptionalPort(port string) bool
```

ValidOptionalPort reports whether port is either an empty string or matches /^:\\d\*$/

<a name="WaitNextMinute"></a>
## func WaitNextMinute

```go
func WaitNextMinute(t ...time.Time)
```

WaitNextMinute 下一分钟, 对齐时间, 0 秒

<a name="WaitNextMinuteWithTime"></a>
## func WaitNextMinuteWithTime

```go
func WaitNextMinuteWithTime(t ...time.Time) (now time.Time)
```

WaitNextMinuteWithTime 下一分钟, 对齐时间, 0 秒

<a name="WaitNextSecond"></a>
## func WaitNextSecond

```go
func WaitNextSecond(t ...time.Time)
```

WaitNextSecond 下一秒, 对齐时间, 0 毫秒 \(近似\)

<a name="WaitNextSecondWithTime"></a>
## func WaitNextSecondWithTime

```go
func WaitNextSecondWithTime(t ...time.Time) (now time.Time)
```

WaitNextSecondWithTime 下一秒, 对齐时间, 0 毫秒 \(近似\)

<a name="WaitSignal"></a>
## func WaitSignal

```go
func WaitSignal(sig ...os.Signal) os.Signal
```

WaitSignal 等待系统信号 默认捕获退出类信息

<a name="WaitUntilMinute"></a>
## func WaitUntilMinute

```go
func WaitUntilMinute(m int, t ...time.Time)
```

WaitUntilMinute 等待, 直到 m 分钟

<a name="WaitUntilSecond"></a>
## func WaitUntilSecond

```go
func WaitUntilSecond(s int, t ...time.Time)
```

WaitUntilSecond 等待, 直到 s 秒

<a name="Zip"></a>
## func Zip

```go
func Zip(data []byte) ([]byte, error)
```



<a name="ZipLevel"></a>
## func ZipLevel

```go
func ZipLevel(data []byte, level int) (dst []byte, err error)
```



<a name="Bool"></a>
## type Bool

A Bool is an atomic boolean value. The zero value is false.

```go
type Bool struct {
    // contains filtered or unexported fields
}
```

<a name="NewBool"></a>
### func NewBool

```go
func NewBool(val bool) *Bool
```



<a name="NewFalse"></a>
### func NewFalse

```go
func NewFalse() *Bool
```



<a name="NewTrue"></a>
### func NewTrue

```go
func NewTrue() *Bool
```



<a name="Bool.CAS"></a>
### func \(\*Bool\) CAS

```go
func (x *Bool) CAS(old, new bool) bool
```



<a name="Bool.CompareAndSwap"></a>
### func \(\*Bool\) CompareAndSwap

```go
func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)
```

CompareAndSwap executes the compare\-and\-swap operation for the boolean value x.

<a name="Bool.Load"></a>
### func \(\*Bool\) Load

```go
func (x *Bool) Load() bool
```

Load atomically loads and returns the value stored in x.

<a name="Bool.MarshalJSON"></a>
### func \(\*Bool\) MarshalJSON

```go
func (x *Bool) MarshalJSON() ([]byte, error)
```



<a name="Bool.Store"></a>
### func \(\*Bool\) Store

```go
func (x *Bool) Store(val bool)
```

Store atomically stores val into x.

<a name="Bool.StoreFalse"></a>
### func \(\*Bool\) StoreFalse

```go
func (x *Bool) StoreFalse()
```



<a name="Bool.StoreTrue"></a>
### func \(\*Bool\) StoreTrue

```go
func (x *Bool) StoreTrue()
```



<a name="Bool.String"></a>
### func \(\*Bool\) String

```go
func (x *Bool) String() string
```



<a name="Bool.Swap"></a>
### func \(\*Bool\) Swap

```go
func (x *Bool) Swap(new bool) (old bool)
```

Swap atomically stores new into x and returns the previous value.

<a name="Bool.Toggle"></a>
### func \(\*Bool\) Toggle

```go
func (x *Bool) Toggle() (old bool)
```

Toggle atomically negates the Boolean and returns the previous value

<a name="Bool.UnmarshalJSON"></a>
### func \(\*Bool\) UnmarshalJSON

```go
func (x *Bool) UnmarshalJSON(b []byte) error
```



<a name="NoCmp"></a>
## type NoCmp

NoCmp is an uncomparable struct. Embed this inside another struct to make it uncomparable.

```
type Foo struct {
  NoCmp
  // ...
}
```

This DOES NOT:

- Disallow shallow copies of structs
- Disallow comparison of pointers to uncomparable structs

```go
type NoCmp [0]func()
```

<a name="NoCopy"></a>
## type NoCopy

NoCopy may be added to structs which must not be copied after the first use.

See https://github.com/golang/go/issues/8005#issuecomment-190753527 for details. and also: https://stackoverflow.com/questions/52494458/nocopy-minimal-example

Note that it must not be embedded, due to the Lock and Unlock methods.

```go
type NoCopy struct{} //nolint:unused
```

<a name="NoCopy.Lock"></a>
### func \(\*NoCopy\) Lock

```go
func (*NoCopy) Lock()
```

Lock is a no\-op used by \-copylocks checker from \`go vet\`.

<a name="NoCopy.Unlock"></a>
### func \(\*NoCopy\) Unlock

```go
func (*NoCopy) Unlock()
```



<a name="RecoveryCallback"></a>
## type RecoveryCallback

RecoveryCallback 自定义恢复信息回调

```go
type RecoveryCallback func(err interface{}, trace []byte)
```

<a name="TryMutex"></a>
## type TryMutex



```go
type TryMutex struct {
    // contains filtered or unexported fields
}
```

<a name="NewTryMutex"></a>
### func NewTryMutex

```go
func NewTryMutex() *TryMutex
```



<a name="TryMutex.Lock"></a>
### func \(\*TryMutex\) Lock

```go
func (m *TryMutex) Lock()
```



<a name="TryMutex.TryLock"></a>
### func \(\*TryMutex\) TryLock

```go
func (m *TryMutex) TryLock(timeout ...time.Duration) bool
```

TryLock 实现可选等待时间尝试获取锁

<a name="TryMutex.Unlock"></a>
### func \(\*TryMutex\) Unlock

```go
func (m *TryMutex) Unlock()
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
