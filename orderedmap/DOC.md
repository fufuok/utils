<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# orderedmap

```go
import "github.com/fufuok/utils/orderedmap"
```

## Index

- [type ByPair](<#ByPair>)
  - [func \(a ByPair\) Len\(\) int](<#ByPair.Len>)
  - [func \(a ByPair\) Less\(i, j int\) bool](<#ByPair.Less>)
  - [func \(a ByPair\) Swap\(i, j int\)](<#ByPair.Swap>)
- [type ByPairOf](<#ByPairOf>)
  - [func \(a ByPairOf\[K, V\]\) Len\(\) int](<#ByPairOf[K, V].Len>)
  - [func \(a ByPairOf\[K, V\]\) Less\(i, j int\) bool](<#ByPairOf[K, V].Less>)
  - [func \(a ByPairOf\[K, V\]\) Swap\(i, j int\)](<#ByPairOf[K, V].Swap>)
- [type OrderedMap](<#OrderedMap>)
  - [func New\(\) \*OrderedMap](<#New>)
  - [func \(o \*OrderedMap\) Delete\(key string\)](<#OrderedMap.Delete>)
  - [func \(o \*OrderedMap\) Get\(key string\) \(interface\{\}, bool\)](<#OrderedMap.Get>)
  - [func \(o \*OrderedMap\) Keys\(\) \[\]string](<#OrderedMap.Keys>)
  - [func \(o OrderedMap\) MarshalJSON\(\) \(\[\]byte, error\)](<#OrderedMap.MarshalJSON>)
  - [func \(o \*OrderedMap\) Set\(key string, value interface\{\}\)](<#OrderedMap.Set>)
  - [func \(o \*OrderedMap\) SetEscapeHTML\(on bool\)](<#OrderedMap.SetEscapeHTML>)
  - [func \(o \*OrderedMap\) Sort\(lessFunc func\(a \*Pair, b \*Pair\) bool\)](<#OrderedMap.Sort>)
  - [func \(o \*OrderedMap\) SortKeys\(sortFunc ...func\(keys \[\]string\)\)](<#OrderedMap.SortKeys>)
  - [func \(o \*OrderedMap\) UnmarshalJSON\(b \[\]byte\) error](<#OrderedMap.UnmarshalJSON>)
  - [func \(o \*OrderedMap\) Values\(\) map\[string\]interface\{\}](<#OrderedMap.Values>)
- [type OrderedMapOf](<#OrderedMapOf>)
  - [func NewOf\[K comparable, V any\]\(\) \*OrderedMapOf\[K, V\]](<#NewOf>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Clone\(\) \*OrderedMapOf\[K, V\]](<#OrderedMapOf[K, V].Clone>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Delete\(key K\)](<#OrderedMapOf[K, V].Delete>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Get\(key K\) \(V, bool\)](<#OrderedMapOf[K, V].Get>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Keys\(\) \[\]K](<#OrderedMapOf[K, V].Keys>)
  - [func \(o \*OrderedMapOf\[K, V\]\) MustGet\(key K\) V](<#OrderedMapOf[K, V].MustGet>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Set\(key K, value V\)](<#OrderedMapOf[K, V].Set>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Sort\(lessFunc func\(a \*PairOf\[K, V\], b \*PairOf\[K, V\]\) bool\)](<#OrderedMapOf[K, V].Sort>)
  - [func \(o \*OrderedMapOf\[K, V\]\) SortKeys\(sortFunc func\(keys \[\]K\)\)](<#OrderedMapOf[K, V].SortKeys>)
  - [func \(o \*OrderedMapOf\[K, V\]\) ToMap\(\) map\[K\]V](<#OrderedMapOf[K, V].ToMap>)
  - [func \(o \*OrderedMapOf\[K, V\]\) Values\(\) map\[K\]V](<#OrderedMapOf[K, V].Values>)
- [type Pair](<#Pair>)
  - [func \(kv \*Pair\) Key\(\) string](<#Pair.Key>)
  - [func \(kv \*Pair\) Value\(\) interface\{\}](<#Pair.Value>)
- [type PairOf](<#PairOf>)
  - [func \(kv \*PairOf\[K, V\]\) Key\(\) K](<#PairOf[K, V].Key>)
  - [func \(kv \*PairOf\[K, V\]\) Value\(\) V](<#PairOf[K, V].Value>)


<a name="ByPair"></a>
## type ByPair



```go
type ByPair struct {
    Pairs    []*Pair
    LessFunc func(a *Pair, j *Pair) bool
}
```

<a name="ByPair.Len"></a>
### func \(ByPair\) Len

```go
func (a ByPair) Len() int
```



<a name="ByPair.Less"></a>
### func \(ByPair\) Less

```go
func (a ByPair) Less(i, j int) bool
```



<a name="ByPair.Swap"></a>
### func \(ByPair\) Swap

```go
func (a ByPair) Swap(i, j int)
```



<a name="ByPairOf"></a>
## type ByPairOf



```go
type ByPairOf[K comparable, V any] struct {
    Pairs    []*PairOf[K, V]
    LessFunc func(a *PairOf[K, V], j *PairOf[K, V]) bool
}
```

<a name="ByPairOf[K, V].Len"></a>
### func \(ByPairOf\[K, V\]\) Len

```go
func (a ByPairOf[K, V]) Len() int
```



<a name="ByPairOf[K, V].Less"></a>
### func \(ByPairOf\[K, V\]\) Less

```go
func (a ByPairOf[K, V]) Less(i, j int) bool
```



<a name="ByPairOf[K, V].Swap"></a>
### func \(ByPairOf\[K, V\]\) Swap

```go
func (a ByPairOf[K, V]) Swap(i, j int)
```



<a name="OrderedMap"></a>
## type OrderedMap



```go
type OrderedMap struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New() *OrderedMap
```



<a name="OrderedMap.Delete"></a>
### func \(\*OrderedMap\) Delete

```go
func (o *OrderedMap) Delete(key string)
```



<a name="OrderedMap.Get"></a>
### func \(\*OrderedMap\) Get

```go
func (o *OrderedMap) Get(key string) (interface{}, bool)
```



<a name="OrderedMap.Keys"></a>
### func \(\*OrderedMap\) Keys

```go
func (o *OrderedMap) Keys() []string
```



<a name="OrderedMap.MarshalJSON"></a>
### func \(OrderedMap\) MarshalJSON

```go
func (o OrderedMap) MarshalJSON() ([]byte, error)
```



<a name="OrderedMap.Set"></a>
### func \(\*OrderedMap\) Set

```go
func (o *OrderedMap) Set(key string, value interface{})
```



<a name="OrderedMap.SetEscapeHTML"></a>
### func \(\*OrderedMap\) SetEscapeHTML

```go
func (o *OrderedMap) SetEscapeHTML(on bool)
```



<a name="OrderedMap.Sort"></a>
### func \(\*OrderedMap\) Sort

```go
func (o *OrderedMap) Sort(lessFunc func(a *Pair, b *Pair) bool)
```

Sort the map using your sort func

<a name="OrderedMap.SortKeys"></a>
### func \(\*OrderedMap\) SortKeys

```go
func (o *OrderedMap) SortKeys(sortFunc ...func(keys []string))
```

SortKeys Sort the map keys using your sort func

<a name="OrderedMap.UnmarshalJSON"></a>
### func \(\*OrderedMap\) UnmarshalJSON

```go
func (o *OrderedMap) UnmarshalJSON(b []byte) error
```



<a name="OrderedMap.Values"></a>
### func \(\*OrderedMap\) Values

```go
func (o *OrderedMap) Values() map[string]interface{}
```



<a name="OrderedMapOf"></a>
## type OrderedMapOf



```go
type OrderedMapOf[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewOf"></a>
### func NewOf

```go
func NewOf[K comparable, V any]() *OrderedMapOf[K, V]
```



<a name="OrderedMapOf[K, V].Clone"></a>
### func \(\*OrderedMapOf\[K, V\]\) Clone

```go
func (o *OrderedMapOf[K, V]) Clone() *OrderedMapOf[K, V]
```



<a name="OrderedMapOf[K, V].Delete"></a>
### func \(\*OrderedMapOf\[K, V\]\) Delete

```go
func (o *OrderedMapOf[K, V]) Delete(key K)
```



<a name="OrderedMapOf[K, V].Get"></a>
### func \(\*OrderedMapOf\[K, V\]\) Get

```go
func (o *OrderedMapOf[K, V]) Get(key K) (V, bool)
```



<a name="OrderedMapOf[K, V].Keys"></a>
### func \(\*OrderedMapOf\[K, V\]\) Keys

```go
func (o *OrderedMapOf[K, V]) Keys() []K
```



<a name="OrderedMapOf[K, V].MustGet"></a>
### func \(\*OrderedMapOf\[K, V\]\) MustGet

```go
func (o *OrderedMapOf[K, V]) MustGet(key K) V
```



<a name="OrderedMapOf[K, V].Set"></a>
### func \(\*OrderedMapOf\[K, V\]\) Set

```go
func (o *OrderedMapOf[K, V]) Set(key K, value V)
```



<a name="OrderedMapOf[K, V].Sort"></a>
### func \(\*OrderedMapOf\[K, V\]\) Sort

```go
func (o *OrderedMapOf[K, V]) Sort(lessFunc func(a *PairOf[K, V], b *PairOf[K, V]) bool)
```

Sort the map using your sort func

<a name="OrderedMapOf[K, V].SortKeys"></a>
### func \(\*OrderedMapOf\[K, V\]\) SortKeys

```go
func (o *OrderedMapOf[K, V]) SortKeys(sortFunc func(keys []K))
```

SortKeys Sort the map keys using your sort func

<a name="OrderedMapOf[K, V].ToMap"></a>
### func \(\*OrderedMapOf\[K, V\]\) ToMap

```go
func (o *OrderedMapOf[K, V]) ToMap() map[K]V
```



<a name="OrderedMapOf[K, V].Values"></a>
### func \(\*OrderedMapOf\[K, V\]\) Values

```go
func (o *OrderedMapOf[K, V]) Values() map[K]V
```



<a name="Pair"></a>
## type Pair



```go
type Pair struct {
    // contains filtered or unexported fields
}
```

<a name="Pair.Key"></a>
### func \(\*Pair\) Key

```go
func (kv *Pair) Key() string
```



<a name="Pair.Value"></a>
### func \(\*Pair\) Value

```go
func (kv *Pair) Value() interface{}
```



<a name="PairOf"></a>
## type PairOf



```go
type PairOf[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="PairOf[K, V].Key"></a>
### func \(\*PairOf\[K, V\]\) Key

```go
func (kv *PairOf[K, V]) Key() K
```



<a name="PairOf[K, V].Value"></a>
### func \(\*PairOf\[K, V\]\) Value

```go
func (kv *PairOf[K, V]) Value() V
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
