<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# orderedmap

```go
import "github.com/fufuok/utils/generic/orderedmap"
```

Package orderedmap Ref: elliotchance/orderedmap

Package orderedmap Ref: elliotchance/orderedmap

## Index

- [type Element](<#type-element>)
  - [func (e *Element[K, V]) Next() *Element[K, V]](<#func-elementk-v-next>)
  - [func (e *Element[K, V]) Prev() *Element[K, V]](<#func-elementk-v-prev>)
- [type List](<#type-list>)
  - [func (l *List[K, V]) Back() *Element[K, V]](<#func-listk-v-back>)
  - [func (l *List[K, V]) Front() *Element[K, V]](<#func-listk-v-front>)
  - [func (l *List[K, V]) IsEmpty() bool](<#func-listk-v-isempty>)
  - [func (l *List[K, V]) PushBack(key K, value V) *Element[K, V]](<#func-listk-v-pushback>)
  - [func (l *List[K, V]) PushFront(key K, value V) *Element[K, V]](<#func-listk-v-pushfront>)
  - [func (l *List[K, V]) Remove(e *Element[K, V])](<#func-listk-v-remove>)
- [type OrderedMap](<#type-orderedmap>)
  - [func NewOrderedMap[K comparable, V any]() *OrderedMap[K, V]](<#func-neworderedmap>)
  - [func (m *OrderedMap[K, V]) Back() *Element[K, V]](<#func-orderedmapk-v-back>)
  - [func (m *OrderedMap[K, V]) Copy() *OrderedMap[K, V]](<#func-orderedmapk-v-copy>)
  - [func (m *OrderedMap[K, V]) Delete(key K) (didDelete bool)](<#func-orderedmapk-v-delete>)
  - [func (m *OrderedMap[K, V]) Front() *Element[K, V]](<#func-orderedmapk-v-front>)
  - [func (m *OrderedMap[K, V]) Get(key K) (value V, ok bool)](<#func-orderedmapk-v-get>)
  - [func (m *OrderedMap[K, V]) GetElement(key K) *Element[K, V]](<#func-orderedmapk-v-getelement>)
  - [func (m *OrderedMap[K, V]) GetOrDefault(key K, defaultValue V) V](<#func-orderedmapk-v-getordefault>)
  - [func (m *OrderedMap[K, V]) Keys() (keys []K)](<#func-orderedmapk-v-keys>)
  - [func (m *OrderedMap[K, V]) Len() int](<#func-orderedmapk-v-len>)
  - [func (m *OrderedMap[K, V]) Set(key K, value V) bool](<#func-orderedmapk-v-set>)


## type Element

Element is an element of a null terminated \(non circular\) intrusive doubly linked list that contains the key of the correspondent element in the ordered map too.

```go
type Element[K comparable, V any] struct {

    // The key that corresponds to this element in the ordered map.
    Key K

    // The value stored with this element.
    Value V
    // contains filtered or unexported fields
}
```

### func \(\*Element\[K, V\]\) Next

```go
func (e *Element[K, V]) Next() *Element[K, V]
```

Next returns the next list element or nil.

### func \(\*Element\[K, V\]\) Prev

```go
func (e *Element[K, V]) Prev() *Element[K, V]
```

Prev returns the previous list element or nil.

## type List

List represents a null terminated \(non circular\) intrusive doubly linked list. The list is immediately usable after instantiation without the need of a dedicated initialization.

```go
type List[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

### func \(\*List\[K, V\]\) Back

```go
func (l *List[K, V]) Back() *Element[K, V]
```

Back returns the last element of list l or nil if the list is empty.

### func \(\*List\[K, V\]\) Front

```go
func (l *List[K, V]) Front() *Element[K, V]
```

Front returns the first element of list l or nil if the list is empty.

### func \(\*List\[K, V\]\) IsEmpty

```go
func (l *List[K, V]) IsEmpty() bool
```

### func \(\*List\[K, V\]\) PushBack

```go
func (l *List[K, V]) PushBack(key K, value V) *Element[K, V]
```

PushBack inserts a new element e with value v at the back of list l and returns e.

### func \(\*List\[K, V\]\) PushFront

```go
func (l *List[K, V]) PushFront(key K, value V) *Element[K, V]
```

PushFront inserts a new element e with value v at the front of list l and returns e.

### func \(\*List\[K, V\]\) Remove

```go
func (l *List[K, V]) Remove(e *Element[K, V])
```

Remove removes e from its list

## type OrderedMap

```go
type OrderedMap[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

### func NewOrderedMap

```go
func NewOrderedMap[K comparable, V any]() *OrderedMap[K, V]
```

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"

	"github.com/fufuok/utils/generic/orderedmap"
)

func main() {
	m := orderedmap.NewOrderedMap[string, any]()

	m.Set("foo", "bar")
	m.Set("qux", 1.23)
	m.Set("123", true)

	fmt.Println(m.Len())
	m.Delete("qux")
	fmt.Println(m.Len())

	// Iterate through all elements from oldest to newest:
	for el := m.Front(); el != nil; el = el.Next() {
		fmt.Println(el.Key, el.Value)
	}

	// You can also use Back and Prev to iterate in reverse:
	for el := m.Back(); el != nil; el = el.Prev() {
		fmt.Println(el.Key, el.Value)
	}

}
```

#### Output

```
3
2
foo bar
123 true
123 true
foo bar
```

</p>
</details>

### func \(\*OrderedMap\[K, V\]\) Back

```go
func (m *OrderedMap[K, V]) Back() *Element[K, V]
```

Back will return the element that is the last \(most recent Set element\). If there are no elements this will return nil.

### func \(\*OrderedMap\[K, V\]\) Copy

```go
func (m *OrderedMap[K, V]) Copy() *OrderedMap[K, V]
```

Copy returns a new OrderedMap with the same elements. Using Copy while there are concurrent writes may mangle the result.

### func \(\*OrderedMap\[K, V\]\) Delete

```go
func (m *OrderedMap[K, V]) Delete(key K) (didDelete bool)
```

Delete will remove a key from the map. It will return true if the key was removed \(the key did exist\).

### func \(\*OrderedMap\[K, V\]\) Front

```go
func (m *OrderedMap[K, V]) Front() *Element[K, V]
```

Front will return the element that is the first \(oldest Set element\). If there are no elements this will return nil.

### func \(\*OrderedMap\[K, V\]\) Get

```go
func (m *OrderedMap[K, V]) Get(key K) (value V, ok bool)
```

Get returns the value for a key. If the key does not exist, the second return parameter will be false and the value will be nil.

### func \(\*OrderedMap\[K, V\]\) GetElement

```go
func (m *OrderedMap[K, V]) GetElement(key K) *Element[K, V]
```

GetElement returns the element for a key. If the key does not exist, the pointer will be nil.

### func \(\*OrderedMap\[K, V\]\) GetOrDefault

```go
func (m *OrderedMap[K, V]) GetOrDefault(key K, defaultValue V) V
```

GetOrDefault returns the value for a key. If the key does not exist, returns the default value instead.

### func \(\*OrderedMap\[K, V\]\) Keys

```go
func (m *OrderedMap[K, V]) Keys() (keys []K)
```

Keys returns all of the keys in the order they were inserted. If a key was replaced it will retain the same position. To ensure most recently set keys are always at the end you must always Delete before Set.

### func \(\*OrderedMap\[K, V\]\) Len

```go
func (m *OrderedMap[K, V]) Len() int
```

Len returns the number of elements in the map.

### func \(\*OrderedMap\[K, V\]\) Set

```go
func (m *OrderedMap[K, V]) Set(key K, value V) bool
```

Set will set \(or replace\) a value for a key. If the key was new, then true will be returned. The returned value will be false if the value was replaced \(even if the value was the same\).



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
