<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xsync

```go
import "github.com/fufuok/utils/xsync"
```

## Index

- [type Counter](<#type-counter>)
  - [func (c *Counter) Add(delta int64)](<#func-counter-add>)
  - [func (c *Counter) Dec()](<#func-counter-dec>)
  - [func (c *Counter) Inc()](<#func-counter-inc>)
  - [func (c *Counter) Reset()](<#func-counter-reset>)
  - [func (c *Counter) Value() int64](<#func-counter-value>)
- [type HashMapOf](<#type-hashmapof>)
  - [func NewHashMapOf[K comparable, V any](hasher ...func(maphash.Seed, K) uint64) HashMapOf[K, V]](<#func-newhashmapof>)
- [type IntegerConstraint](<#type-integerconstraint>)
- [type MPMCQueue](<#type-mpmcqueue>)
  - [func NewMPMCQueue(capacity int) *MPMCQueue](<#func-newmpmcqueue>)
  - [func (q *MPMCQueue) Dequeue() interface{}](<#func-mpmcqueue-dequeue>)
  - [func (q *MPMCQueue) Enqueue(item interface{})](<#func-mpmcqueue-enqueue>)
  - [func (q *MPMCQueue) TryDequeue() (item interface{}, ok bool)](<#func-mpmcqueue-trydequeue>)
  - [func (q *MPMCQueue) TryEnqueue(item interface{}) bool](<#func-mpmcqueue-tryenqueue>)
- [type Map](<#type-map>)
  - [func NewMap() *Map](<#func-newmap>)
  - [func (m *Map) Delete(key string)](<#func-map-delete>)
  - [func (m *Map) Load(key string) (value interface{}, ok bool)](<#func-map-load>)
  - [func (m *Map) LoadAndDelete(key string) (value interface{}, loaded bool)](<#func-map-loadanddelete>)
  - [func (m *Map) LoadAndStore(key string, value interface{}) (actual interface{}, loaded bool)](<#func-map-loadandstore>)
  - [func (m *Map) LoadOrCompute(key string, valueFn func() interface{}) (actual interface{}, loaded bool)](<#func-map-loadorcompute>)
  - [func (m *Map) LoadOrStore(key string, value interface{}) (actual interface{}, loaded bool)](<#func-map-loadorstore>)
  - [func (m *Map) Range(f func(key string, value interface{}) bool)](<#func-map-range>)
  - [func (m *Map) Size() int](<#func-map-size>)
  - [func (m *Map) Store(key string, value interface{})](<#func-map-store>)
- [type MapOf](<#type-mapof>)
  - [func NewIntegerMapOf[K IntegerConstraint, V any]() *MapOf[K, V]](<#func-newintegermapof>)
  - [func NewMapOf[V any]() *MapOf[string, V]](<#func-newmapof>)
  - [func NewTypedMapOf[K comparable, V any](hasher func(maphash.Seed, K) uint64) *MapOf[K, V]](<#func-newtypedmapof>)
  - [func (m *MapOf[K, V]) Delete(key K)](<#func-mapofk-v-delete>)
  - [func (m *MapOf[K, V]) Load(key K) (value V, ok bool)](<#func-mapofk-v-load>)
  - [func (m *MapOf[K, V]) LoadAndDelete(key K) (value V, loaded bool)](<#func-mapofk-v-loadanddelete>)
  - [func (m *MapOf[K, V]) LoadAndStore(key K, value V) (actual V, loaded bool)](<#func-mapofk-v-loadandstore>)
  - [func (m *MapOf[K, V]) LoadOrCompute(key K, valueFn func() V) (actual V, loaded bool)](<#func-mapofk-v-loadorcompute>)
  - [func (m *MapOf[K, V]) LoadOrStore(key K, value V) (actual V, loaded bool)](<#func-mapofk-v-loadorstore>)
  - [func (m *MapOf[K, V]) Range(f func(key K, value V) bool)](<#func-mapofk-v-range>)
  - [func (m *MapOf[K, V]) Size() int](<#func-mapofk-v-size>)
  - [func (m *MapOf[K, V]) Store(key K, value V)](<#func-mapofk-v-store>)
- [type RBMutex](<#type-rbmutex>)
  - [func (m *RBMutex) Lock()](<#func-rbmutex-lock>)
  - [func (m *RBMutex) RLock() *RToken](<#func-rbmutex-rlock>)
  - [func (m *RBMutex) RUnlock(t *RToken)](<#func-rbmutex-runlock>)
  - [func (m *RBMutex) Unlock()](<#func-rbmutex-unlock>)
- [type RToken](<#type-rtoken>)


## type Counter

A Counter is a striped int64 counter.

Should be preferred over a single atomically updated int64 counter in high contention scenarios.

A Counter must not be copied after first use.

```go
type Counter struct {
    // contains filtered or unexported fields
}
```

### func \(\*Counter\) Add

```go
func (c *Counter) Add(delta int64)
```

Add adds the delta to the counter.

### func \(\*Counter\) Dec

```go
func (c *Counter) Dec()
```

Dec decrements the counter by 1.

### func \(\*Counter\) Inc

```go
func (c *Counter) Inc()
```

Inc increments the counter by 1.

### func \(\*Counter\) Reset

```go
func (c *Counter) Reset()
```

Reset resets the counter to zero. This method should only be used when it is known that there are no concurrent modifications of the counter.

### func \(\*Counter\) Value

```go
func (c *Counter) Value() int64
```

Value returns the current counter value. The returned value may not include all of the latest operations in presence of concurrent modifications of the counter.

## type HashMapOf

```go
type HashMapOf[K comparable, V any] interface {
    // Load returns the value stored in the map for a key, or nil if no
    // value is present.
    // The ok result indicates whether value was found in the map.
    Load(key K) (value V, ok bool)

    // Store sets the value for a key.
    Store(key K, value V)

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(key K, value V) (actual V, loaded bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // It stores the new value and returns the existing one, if present.
    // The loaded result is true if the existing value was loaded,
    // false otherwise.
    LoadAndStore(key K, value V) (actual V, loaded bool)

    // LoadOrCompute returns the existing value for the key if present.
    // Otherwise, it computes the value using the provided function and
    // returns the computed value. The loaded result is true if the value
    // was loaded, false if stored.
    LoadOrCompute(key K, valueFn func() V) (actual V, loaded bool)

    // LoadAndDelete deletes the value for a key, returning the previous
    // value if any. The loaded result reports whether the key was
    // present.
    LoadAndDelete(key K) (value V, loaded bool)

    // Delete deletes the value for a key.
    Delete(key K)

    // Range calls f sequentially for each key and value present in the
    // map. If f returns false, range stops the iteration.
    //
    // Range does not necessarily correspond to any consistent snapshot
    // of the Map's contents: no key will be visited more than once, but
    // if the value for any key is stored or deleted concurrently, Range
    // may reflect any mapping for that key from any point during the
    // Range call.
    //
    // It is safe to modify the map while iterating it. However, the
    // concurrent modification rule apply, i.e. the changes may be not
    // reflected in the subsequently iterated entries.
    Range(f func(key K, value V) bool)

    // Size returns current size of the map.
    Size() int
}
```

### func NewHashMapOf

```go
func NewHashMapOf[K comparable, V any](hasher ...func(maphash.Seed, K) uint64) HashMapOf[K, V]
```

NewHashMapOf creates a new HashMapOf instance with arbitrarily typed keys. If no hasher is specified, an automatic generation will be attempted. Hashable allowed map key types constraint. Automatically generated hashes for these types are safe:

```
type Hashable interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
	~float32 | ~float64 | ~string | ~complex64 | ~complex128
}
```

## type IntegerConstraint

IntegerConstraint represents any integer type.

```go
type IntegerConstraint interface {
    // contains filtered or unexported methods
}
```

## type MPMCQueue

A MPMCQueue is a bounded multi\-producer multi\-consumer concurrent queue.

MPMCQueue instances must be created with NewMPMCQueue function. A MPMCQueue must not be copied after first use.

Based on the data structure from the following C\+\+ library: https://github.com/rigtorp/MPMCQueue

```go
type MPMCQueue struct {
    // contains filtered or unexported fields
}
```

### func NewMPMCQueue

```go
func NewMPMCQueue(capacity int) *MPMCQueue
```

NewMPMCQueue creates a new MPMCQueue instance with the given capacity.

### func \(\*MPMCQueue\) Dequeue

```go
func (q *MPMCQueue) Dequeue() interface{}
```

Dequeue retrieves and removes the item from the head of the queue. Blocks, if the queue is empty.

### func \(\*MPMCQueue\) Enqueue

```go
func (q *MPMCQueue) Enqueue(item interface{})
```

Enqueue inserts the given item into the queue. Blocks, if the queue is full.

### func \(\*MPMCQueue\) TryDequeue

```go
func (q *MPMCQueue) TryDequeue() (item interface{}, ok bool)
```

TryDequeue retrieves and removes the item from the head of the queue. Does not block and returns immediately. The ok result indicates that the queue isn't empty and an item was retrieved.

### func \(\*MPMCQueue\) TryEnqueue

```go
func (q *MPMCQueue) TryEnqueue(item interface{}) bool
```

TryEnqueue inserts the given item into the queue. Does not block and returns immediately. The result indicates that the queue isn't full and the item was inserted.

## type Map

Map is like a Go map\[string\]interface\{\} but is safe for concurrent use by multiple goroutines without additional locking or coordination. It follows the interface of sync.Map.

A Map must not be copied after first use.

Map uses a modified version of Cache\-Line Hash Table \(CLHT\) data structure: https://github.com/LPD-EPFL/CLHT

CLHT is built around idea to organize the hash table in cache\-line\-sized buckets, so that on all modern CPUs update operations complete with at most one cache\-line transfer. Also, Get operations involve no write to memory, as well as no mutexes or any other sort of locks. Due to this design, in all considered scenarios Map outperforms sync.Map.

One important difference with sync.Map is that only string keys are supported. That's because Golang standard library does not expose the built\-in hash functions for interface\{\} values.

```go
type Map struct {
    // contains filtered or unexported fields
}
```

### func NewMap

```go
func NewMap() *Map
```

NewMap creates a new Map instance.

### func \(\*Map\) Delete

```go
func (m *Map) Delete(key string)
```

Delete deletes the value for a key.

### func \(\*Map\) Load

```go
func (m *Map) Load(key string) (value interface{}, ok bool)
```

Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.

### func \(\*Map\) LoadAndDelete

```go
func (m *Map) LoadAndDelete(key string) (value interface{}, loaded bool)
```

LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.

### func \(\*Map\) LoadAndStore

```go
func (m *Map) LoadAndStore(key string, value interface{}) (actual interface{}, loaded bool)
```

LoadAndStore returns the existing value for the key if present, while setting the new value for the key. It stores the new value and returns the existing one, if present. The loaded result is true if the existing value was loaded, false otherwise.

### func \(\*Map\) LoadOrCompute

```go
func (m *Map) LoadOrCompute(key string, valueFn func() interface{}) (actual interface{}, loaded bool)
```

LoadOrCompute returns the existing value for the key if present. Otherwise, it computes the value using the provided function and returns the computed value. The loaded result is true if the value was loaded, false if stored.

### func \(\*Map\) LoadOrStore

```go
func (m *Map) LoadOrStore(key string, value interface{}) (actual interface{}, loaded bool)
```

LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.

### func \(\*Map\) Range

```go
func (m *Map) Range(f func(key string, value interface{}) bool)
```

Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.

Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.

It is safe to modify the map while iterating it. However, the concurrent modification rule apply, i.e. the changes may be not reflected in the subsequently iterated entries.

### func \(\*Map\) Size

```go
func (m *Map) Size() int
```

Size returns current size of the map.

### func \(\*Map\) Store

```go
func (m *Map) Store(key string, value interface{})
```

Store sets the value for a key.

## type MapOf

MapOf is like a Go map\[string\]V but is safe for concurrent use by multiple goroutines without additional locking or coordination. It follows the interface of sync.Map.

A MapOf must not be copied after first use.

MapOf uses a modified version of Cache\-Line Hash Table \(CLHT\) data structure: https://github.com/LPD-EPFL/CLHT

CLHT is built around idea to organize the hash table in cache\-line\-sized buckets, so that on all modern CPUs update operations complete with at most one cache\-line transfer. Also, Get operations involve no write to memory, as well as no mutexes or any other sort of locks. Due to this design, in all considered scenarios MapOf outperforms sync.Map.

One important difference with sync.Map is that only string keys are supported. That's because Golang standard library does not expose the built\-in hash functions for interface\{\} values.

```go
type MapOf[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

### func NewIntegerMapOf

```go
func NewIntegerMapOf[K IntegerConstraint, V any]() *MapOf[K, V]
```

NewIntegerMapOf creates a new MapOf instance with integer typed keys.

### func NewMapOf

```go
func NewMapOf[V any]() *MapOf[string, V]
```

NewMapOf creates a new MapOf instance with string keys

### func NewTypedMapOf

```go
func NewTypedMapOf[K comparable, V any](hasher func(maphash.Seed, K) uint64) *MapOf[K, V]
```

NewTypedMapOf creates a new MapOf instance with arbitrarily typed keys. Keys are hashed to uint64 using the hasher function. It is strongly recommended to use the hash/maphash package to implement hasher. See the example for how to do that.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"encoding/binary"
	"hash/maphash"
	"time"

	"github.com/fufuok/utils/xsync"
)

func main() {
	type Person struct {
		GivenName   string
		FamilyName  string
		YearOfBirth int16
	}
	age := xsync.NewTypedMapOf[Person, int](func(seed maphash.Seed, p Person) uint64 {
		var h maphash.Hash
		h.SetSeed(seed)
		h.WriteString(p.GivenName)
		hash := h.Sum64()
		h.Reset()
		h.WriteString(p.FamilyName)
		hash = 31*hash + h.Sum64()
		h.Reset()
		binary.Write(&h, binary.LittleEndian, p.YearOfBirth)
		return 31*hash + h.Sum64()
	})
	Y := time.Now().Year()
	age.Store(Person{"Ada", "Lovelace", 1815}, Y-1815)
	age.Store(Person{"Charles", "Babbage", 1791}, Y-1791)
}
```

</p>
</details>

### func \(\*MapOf\[K, V\]\) Delete

```go
func (m *MapOf[K, V]) Delete(key K)
```

Delete deletes the value for a key.

### func \(\*MapOf\[K, V\]\) Load

```go
func (m *MapOf[K, V]) Load(key K) (value V, ok bool)
```

Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.

### func \(\*MapOf\[K, V\]\) LoadAndDelete

```go
func (m *MapOf[K, V]) LoadAndDelete(key K) (value V, loaded bool)
```

LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.

### func \(\*MapOf\[K, V\]\) LoadAndStore

```go
func (m *MapOf[K, V]) LoadAndStore(key K, value V) (actual V, loaded bool)
```

LoadAndStore returns the existing value for the key if present, while setting the new value for the key. It stores the new value and returns the existing one, if present. The loaded result is true if the existing value was loaded, false otherwise.

### func \(\*MapOf\[K, V\]\) LoadOrCompute

```go
func (m *MapOf[K, V]) LoadOrCompute(key K, valueFn func() V) (actual V, loaded bool)
```

LoadOrCompute returns the existing value for the key if present. Otherwise, it computes the value using the provided function and returns the computed value. The loaded result is true if the value was loaded, false if stored.

### func \(\*MapOf\[K, V\]\) LoadOrStore

```go
func (m *MapOf[K, V]) LoadOrStore(key K, value V) (actual V, loaded bool)
```

LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.

### func \(\*MapOf\[K, V\]\) Range

```go
func (m *MapOf[K, V]) Range(f func(key K, value V) bool)
```

Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.

Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.

It is safe to modify the map while iterating it. However, the concurrent modification rule apply, i.e. the changes may be not reflected in the subsequently iterated entries.

### func \(\*MapOf\[K, V\]\) Size

```go
func (m *MapOf[K, V]) Size() int
```

Size returns current size of the map.

### func \(\*MapOf\[K, V\]\) Store

```go
func (m *MapOf[K, V]) Store(key K, value V)
```

Store sets the value for a key.

## type RBMutex

A RBMutex is a reader biased reader/writer mutual exclusion lock. The lock can be held by an many readers or a single writer. The zero value for a RBMutex is an unlocked mutex.

A RBMutex must not be copied after first use.

RBMutex is based on the BRAVO \(Biased Locking for Reader\-Writer Locks\) algorithm: https://arxiv.org/pdf/1810.01553.pdf

RBMutex is a specialized mutex for scenarios, such as caches, where the vast majority of locks are acquired by readers and write lock acquire attempts are infrequent. In such scenarios, RBMutex performs better than the sync.RWMutex on large multicore machines.

RBMutex extends sync.RWMutex internally and uses it as the "reader bias disabled" fallback, so the same semantics apply. The only noticeable difference is in reader tokens returned from the RLock/RUnlock methods.

```go
type RBMutex struct {
    // contains filtered or unexported fields
}
```

### func \(\*RBMutex\) Lock

```go
func (m *RBMutex) Lock()
```

Lock locks m for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.

### func \(\*RBMutex\) RLock

```go
func (m *RBMutex) RLock() *RToken
```

RLock locks m for reading and returns a reader token. The token must be used in the later RUnlock call.

Should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock.

### func \(\*RBMutex\) RUnlock

```go
func (m *RBMutex) RUnlock(t *RToken)
```

RUnlock undoes a single RLock call. A reader token obtained from the RLock call must be provided. RUnlock does not affect other simultaneous readers. A panic is raised if m is not locked for reading on entry to RUnlock.

### func \(\*RBMutex\) Unlock

```go
func (m *RBMutex) Unlock()
```

Unlock unlocks m for writing. A panic is raised if m is not locked for writing on entry to Unlock.

As with RWMutex, a locked RBMutex is not associated with a particular goroutine. One goroutine may RLock \(Lock\) a RBMutex and then arrange for another goroutine to RUnlock \(Unlock\) it.

## type RToken

RToken is a reader lock token.

```go
type RToken struct {
    // contains filtered or unexported fields
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
