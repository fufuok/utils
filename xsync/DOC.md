<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xsync

```go
import "github.com/fufuok/utils/xsync"
```

## Index

- [type Counter](<#Counter>)
  - [func NewCounter\(\) \*Counter](<#NewCounter>)
  - [func \(c \*Counter\) Add\(delta int64\)](<#Counter.Add>)
  - [func \(c \*Counter\) Dec\(\)](<#Counter.Dec>)
  - [func \(c \*Counter\) Inc\(\)](<#Counter.Inc>)
  - [func \(c \*Counter\) Reset\(\)](<#Counter.Reset>)
  - [func \(c \*Counter\) Value\(\) int64](<#Counter.Value>)
- [type HashMapOf](<#HashMapOf>)
- [type MPMCQueue](<#MPMCQueue>)
  - [func NewMPMCQueue\(capacity int\) \*MPMCQueue](<#NewMPMCQueue>)
  - [func \(q \*MPMCQueue\) Dequeue\(\) interface\{\}](<#MPMCQueue.Dequeue>)
  - [func \(q \*MPMCQueue\) Enqueue\(item interface\{\}\)](<#MPMCQueue.Enqueue>)
  - [func \(q \*MPMCQueue\) TryDequeue\(\) \(item interface\{\}, ok bool\)](<#MPMCQueue.TryDequeue>)
  - [func \(q \*MPMCQueue\) TryEnqueue\(item interface\{\}\) bool](<#MPMCQueue.TryEnqueue>)
- [type MPMCQueueOf](<#MPMCQueueOf>)
  - [func NewMPMCQueueOf\[I any\]\(capacity int\) \*MPMCQueueOf\[I\]](<#NewMPMCQueueOf>)
  - [func \(q \*MPMCQueueOf\[I\]\) Dequeue\(\) I](<#MPMCQueueOf[I].Dequeue>)
  - [func \(q \*MPMCQueueOf\[I\]\) Enqueue\(item I\)](<#MPMCQueueOf[I].Enqueue>)
  - [func \(q \*MPMCQueueOf\[I\]\) TryDequeue\(\) \(item I, ok bool\)](<#MPMCQueueOf[I].TryDequeue>)
  - [func \(q \*MPMCQueueOf\[I\]\) TryEnqueue\(item I\) bool](<#MPMCQueueOf[I].TryEnqueue>)
- [type Map](<#Map>)
  - [func NewMap\(\) \*Map](<#NewMap>)
  - [func NewMapPresized\(sizeHint int\) \*Map](<#NewMapPresized>)
  - [func \(m \*Map\) Clear\(\)](<#Map.Clear>)
  - [func \(m \*Map\) Compute\(key string, valueFn func\(oldValue interface\{\}, loaded bool\) \(newValue interface\{\}, delete bool\)\) \(actual interface\{\}, ok bool\)](<#Map.Compute>)
  - [func \(m \*Map\) Delete\(key string\)](<#Map.Delete>)
  - [func \(m \*Map\) Load\(key string\) \(value interface\{\}, ok bool\)](<#Map.Load>)
  - [func \(m \*Map\) LoadAndDelete\(key string\) \(value interface\{\}, loaded bool\)](<#Map.LoadAndDelete>)
  - [func \(m \*Map\) LoadAndStore\(key string, value interface\{\}\) \(actual interface\{\}, loaded bool\)](<#Map.LoadAndStore>)
  - [func \(m \*Map\) LoadOrCompute\(key string, valueFn func\(\) interface\{\}\) \(actual interface\{\}, loaded bool\)](<#Map.LoadOrCompute>)
  - [func \(m \*Map\) LoadOrStore\(key string, value interface\{\}\) \(actual interface\{\}, loaded bool\)](<#Map.LoadOrStore>)
  - [func \(m \*Map\) Range\(f func\(key string, value interface\{\}\) bool\)](<#Map.Range>)
  - [func \(m \*Map\) Size\(\) int](<#Map.Size>)
  - [func \(m \*Map\) Store\(key string, value interface\{\}\)](<#Map.Store>)
- [type MapOf](<#MapOf>)
  - [func NewMapOf\[K comparable, V any\]\(\) \*MapOf\[K, V\]](<#NewMapOf>)
  - [func NewMapOfPresized\[K comparable, V any\]\(sizeHint int\) \*MapOf\[K, V\]](<#NewMapOfPresized>)
  - [func \(m \*MapOf\[K, V\]\) Clear\(\)](<#MapOf[K, V].Clear>)
  - [func \(m \*MapOf\[K, V\]\) Compute\(key K, valueFn func\(oldValue V, loaded bool\) \(newValue V, delete bool\)\) \(actual V, ok bool\)](<#MapOf[K, V].Compute>)
  - [func \(m \*MapOf\[K, V\]\) Delete\(key K\)](<#MapOf[K, V].Delete>)
  - [func \(m \*MapOf\[K, V\]\) Load\(key K\) \(value V, ok bool\)](<#MapOf[K, V].Load>)
  - [func \(m \*MapOf\[K, V\]\) LoadAndDelete\(key K\) \(value V, loaded bool\)](<#MapOf[K, V].LoadAndDelete>)
  - [func \(m \*MapOf\[K, V\]\) LoadAndStore\(key K, value V\) \(actual V, loaded bool\)](<#MapOf[K, V].LoadAndStore>)
  - [func \(m \*MapOf\[K, V\]\) LoadOrCompute\(key K, valueFn func\(\) V\) \(actual V, loaded bool\)](<#MapOf[K, V].LoadOrCompute>)
  - [func \(m \*MapOf\[K, V\]\) LoadOrStore\(key K, value V\) \(actual V, loaded bool\)](<#MapOf[K, V].LoadOrStore>)
  - [func \(m \*MapOf\[K, V\]\) Range\(f func\(key K, value V\) bool\)](<#MapOf[K, V].Range>)
  - [func \(m \*MapOf\[K, V\]\) Size\(\) int](<#MapOf[K, V].Size>)
  - [func \(m \*MapOf\[K, V\]\) Store\(key K, value V\)](<#MapOf[K, V].Store>)
- [type RBMutex](<#RBMutex>)
  - [func NewRBMutex\(\) \*RBMutex](<#NewRBMutex>)
  - [func \(mu \*RBMutex\) Lock\(\)](<#RBMutex.Lock>)
  - [func \(mu \*RBMutex\) RLock\(\) \*RToken](<#RBMutex.RLock>)
  - [func \(mu \*RBMutex\) RUnlock\(t \*RToken\)](<#RBMutex.RUnlock>)
  - [func \(mu \*RBMutex\) Unlock\(\)](<#RBMutex.Unlock>)
- [type RToken](<#RToken>)


<a name="Counter"></a>
## type Counter

A Counter is a striped int64 counter.

Should be preferred over a single atomically updated int64 counter in high contention scenarios.

A Counter must not be copied after first use.

```go
type Counter struct {
    // contains filtered or unexported fields
}
```

<a name="NewCounter"></a>
### func NewCounter

```go
func NewCounter() *Counter
```

NewCounter creates a new Counter instance.

<a name="Counter.Add"></a>
### func \(\*Counter\) Add

```go
func (c *Counter) Add(delta int64)
```

Add adds the delta to the counter.

<a name="Counter.Dec"></a>
### func \(\*Counter\) Dec

```go
func (c *Counter) Dec()
```

Dec decrements the counter by 1.

<a name="Counter.Inc"></a>
### func \(\*Counter\) Inc

```go
func (c *Counter) Inc()
```

Inc increments the counter by 1.

<a name="Counter.Reset"></a>
### func \(\*Counter\) Reset

```go
func (c *Counter) Reset()
```

Reset resets the counter to zero. This method should only be used when it is known that there are no concurrent modifications of the counter.

<a name="Counter.Value"></a>
### func \(\*Counter\) Value

```go
func (c *Counter) Value() int64
```

Value returns the current counter value. The returned value may not include all of the latest operations in presence of concurrent modifications of the counter.

<a name="HashMapOf"></a>
## type HashMapOf



```go
type HashMapOf[K comparable, V any] interface {
    // Load returns the value stored in the map for a key, or nil if no
    // value is present.
    // The ok result indicates whether value was found in the map.
    Load(key K) (value V, ok bool)

    // Store sets the value for a key.
    Store(key K, value V)

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(key K, value V) (actual V, loaded bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // It stores the new value and returns the existing one, if present.
    // The loaded result is true if the existing value was loaded,
    // false otherwise.
    LoadAndStore(key K, value V) (actual V, loaded bool)

    // LoadOrCompute returns the existing value for the key if present.
    // Otherwise, it computes the value using the provided function and
    // returns the computed value. The loaded result is true if the value
    // was loaded, false if stored.
    LoadOrCompute(key K, valueFn func() V) (actual V, loaded bool)

    // Compute either sets the computed new value for the key or deletes
    // the value for the key. When the delete result of the valueFn function
    // is set to true, the value will be deleted, if it exists. When delete
    // is set to false, the value is updated to the newValue.
    // The ok result indicates whether value was computed and stored, thus, is
    // present in the map. The actual result contains the new value in cases where
    // the value was computed and stored. See the example for a few use cases.
    Compute(
        key K,
        valueFn func(oldValue V, loaded bool) (newValue V, delete bool),
    ) (actual V, ok bool)

    // LoadAndDelete deletes the value for a key, returning the previous
    // value if any. The loaded result reports whether the key was
    // present.
    LoadAndDelete(key K) (value V, loaded bool)

    // Delete deletes the value for a key.
    Delete(key K)

    // Range calls f sequentially for each key and value present in the
    // map. If f returns false, range stops the iteration.
    //
    // Range does not necessarily correspond to any consistent snapshot
    // of the Map's contents: no key will be visited more than once, but
    // if the value for any key is stored or deleted concurrently, Range
    // may reflect any mapping for that key from any point during the
    // Range call.
    //
    // It is safe to modify the map while iterating it. However, the
    // concurrent modification rule apply, i.e. the changes may be not
    // reflected in the subsequently iterated entries.
    Range(f func(key K, value V) bool)

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Size returns current size of the map.
    Size() int
}
```

<a name="MPMCQueue"></a>
## type MPMCQueue

A MPMCQueue is a bounded multi\-producer multi\-consumer concurrent queue.

MPMCQueue instances must be created with NewMPMCQueue function. A MPMCQueue must not be copied after first use.

Based on the data structure from the following C\+\+ library: https://github.com/rigtorp/MPMCQueue

```go
type MPMCQueue struct {
    // contains filtered or unexported fields
}
```

<a name="NewMPMCQueue"></a>
### func NewMPMCQueue

```go
func NewMPMCQueue(capacity int) *MPMCQueue
```

NewMPMCQueue creates a new MPMCQueue instance with the given capacity.

<a name="MPMCQueue.Dequeue"></a>
### func \(\*MPMCQueue\) Dequeue

```go
func (q *MPMCQueue) Dequeue() interface{}
```

Dequeue retrieves and removes the item from the head of the queue. Blocks, if the queue is empty.

<a name="MPMCQueue.Enqueue"></a>
### func \(\*MPMCQueue\) Enqueue

```go
func (q *MPMCQueue) Enqueue(item interface{})
```

Enqueue inserts the given item into the queue. Blocks, if the queue is full.

<a name="MPMCQueue.TryDequeue"></a>
### func \(\*MPMCQueue\) TryDequeue

```go
func (q *MPMCQueue) TryDequeue() (item interface{}, ok bool)
```

TryDequeue retrieves and removes the item from the head of the queue. Does not block and returns immediately. The ok result indicates that the queue isn't empty and an item was retrieved.

<a name="MPMCQueue.TryEnqueue"></a>
### func \(\*MPMCQueue\) TryEnqueue

```go
func (q *MPMCQueue) TryEnqueue(item interface{}) bool
```

TryEnqueue inserts the given item into the queue. Does not block and returns immediately. The result indicates that the queue isn't full and the item was inserted.

<a name="MPMCQueueOf"></a>
## type MPMCQueueOf

A MPMCQueueOf is a bounded multi\-producer multi\-consumer concurrent queue. It's a generic version of MPMCQueue.

MPMCQueue instances must be created with NewMPMCQueueOf function. A MPMCQueueOf must not be copied after first use.

Based on the data structure from the following C\+\+ library: https://github.com/rigtorp/MPMCQueue

```go
type MPMCQueueOf[I any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewMPMCQueueOf"></a>
### func NewMPMCQueueOf

```go
func NewMPMCQueueOf[I any](capacity int) *MPMCQueueOf[I]
```

NewMPMCQueueOf creates a new MPMCQueueOf instance with the given capacity.

<a name="MPMCQueueOf[I].Dequeue"></a>
### func \(\*MPMCQueueOf\[I\]\) Dequeue

```go
func (q *MPMCQueueOf[I]) Dequeue() I
```

Dequeue retrieves and removes the item from the head of the queue. Blocks, if the queue is empty.

<a name="MPMCQueueOf[I].Enqueue"></a>
### func \(\*MPMCQueueOf\[I\]\) Enqueue

```go
func (q *MPMCQueueOf[I]) Enqueue(item I)
```

Enqueue inserts the given item into the queue. Blocks, if the queue is full.

<a name="MPMCQueueOf[I].TryDequeue"></a>
### func \(\*MPMCQueueOf\[I\]\) TryDequeue

```go
func (q *MPMCQueueOf[I]) TryDequeue() (item I, ok bool)
```

TryDequeue retrieves and removes the item from the head of the queue. Does not block and returns immediately. The ok result indicates that the queue isn't empty and an item was retrieved.

<a name="MPMCQueueOf[I].TryEnqueue"></a>
### func \(\*MPMCQueueOf\[I\]\) TryEnqueue

```go
func (q *MPMCQueueOf[I]) TryEnqueue(item I) bool
```

TryEnqueue inserts the given item into the queue. Does not block and returns immediately. The result indicates that the queue isn't full and the item was inserted.

<a name="Map"></a>
## type Map

Map is like a Go map\[string\]interface\{\} but is safe for concurrent use by multiple goroutines without additional locking or coordination. It follows the interface of sync.Map with a number of valuable extensions like Compute or Size.

A Map must not be copied after first use.

Map uses a modified version of Cache\-Line Hash Table \(CLHT\) data structure: https://github.com/LPD-EPFL/CLHT

CLHT is built around idea to organize the hash table in cache\-line\-sized buckets, so that on all modern CPUs update operations complete with at most one cache\-line transfer. Also, Get operations involve no write to memory, as well as no mutexes or any other sort of locks. Due to this design, in all considered scenarios Map outperforms sync.Map.

One important difference with sync.Map is that only string keys are supported. That's because Golang standard library does not expose the built\-in hash functions for interface\{\} values.

```go
type Map struct {
    // contains filtered or unexported fields
}
```

<a name="NewMap"></a>
### func NewMap

```go
func NewMap() *Map
```

NewMap creates a new Map instance.

<a name="NewMapPresized"></a>
### func NewMapPresized

```go
func NewMapPresized(sizeHint int) *Map
```

NewMapPresized creates a new Map instance with capacity enough to hold sizeHint entries. The capacity is treated as the minimal capacity meaning that the underlying hash table will never shrink to a smaller capacity. If sizeHint is zero or negative, the value is ignored.

<a name="Map.Clear"></a>
### func \(\*Map\) Clear

```go
func (m *Map) Clear()
```

Clear deletes all keys and values currently stored in the map.

<a name="Map.Compute"></a>
### func \(\*Map\) Compute

```go
func (m *Map) Compute(key string, valueFn func(oldValue interface{}, loaded bool) (newValue interface{}, delete bool)) (actual interface{}, ok bool)
```

Compute either sets the computed new value for the key or deletes the value for the key. When the delete result of the valueFn function is set to true, the value will be deleted, if it exists. When delete is set to false, the value is updated to the newValue. The ok result indicates whether value was computed and stored, thus, is present in the map. The actual result contains the new value in cases where the value was computed and stored. See the example for a few use cases.

This call locks a hash table bucket while the compute function is executed. It means that modifications on other entries in the bucket will be blocked until the valueFn executes. Consider this when the function includes long\-running operations.

<a name="Map.Delete"></a>
### func \(\*Map\) Delete

```go
func (m *Map) Delete(key string)
```

Delete deletes the value for a key.

<a name="Map.Load"></a>
### func \(\*Map\) Load

```go
func (m *Map) Load(key string) (value interface{}, ok bool)
```

Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.

<a name="Map.LoadAndDelete"></a>
### func \(\*Map\) LoadAndDelete

```go
func (m *Map) LoadAndDelete(key string) (value interface{}, loaded bool)
```

LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.

<a name="Map.LoadAndStore"></a>
### func \(\*Map\) LoadAndStore

```go
func (m *Map) LoadAndStore(key string, value interface{}) (actual interface{}, loaded bool)
```

LoadAndStore returns the existing value for the key if present, while setting the new value for the key. It stores the new value and returns the existing one, if present. The loaded result is true if the existing value was loaded, false otherwise.

<a name="Map.LoadOrCompute"></a>
### func \(\*Map\) LoadOrCompute

```go
func (m *Map) LoadOrCompute(key string, valueFn func() interface{}) (actual interface{}, loaded bool)
```

LoadOrCompute returns the existing value for the key if present. Otherwise, it computes the value using the provided function and returns the computed value. The loaded result is true if the value was loaded, false if stored.

This call locks a hash table bucket while the compute function is executed. It means that modifications on other entries in the bucket will be blocked until the valueFn executes. Consider this when the function includes long\-running operations.

<a name="Map.LoadOrStore"></a>
### func \(\*Map\) LoadOrStore

```go
func (m *Map) LoadOrStore(key string, value interface{}) (actual interface{}, loaded bool)
```

LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.

<a name="Map.Range"></a>
### func \(\*Map\) Range

```go
func (m *Map) Range(f func(key string, value interface{}) bool)
```

Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.

Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.

It is safe to modify the map while iterating it, including entry creation, modification and deletion. However, the concurrent modification rule apply, i.e. the changes may be not reflected in the subsequently iterated entries.

<a name="Map.Size"></a>
### func \(\*Map\) Size

```go
func (m *Map) Size() int
```

Size returns current size of the map.

<a name="Map.Store"></a>
### func \(\*Map\) Store

```go
func (m *Map) Store(key string, value interface{})
```

Store sets the value for a key.

<a name="MapOf"></a>
## type MapOf

MapOf is like a Go map\[K\]V but is safe for concurrent use by multiple goroutines without additional locking or coordination. It follows the interface of sync.Map with a number of valuable extensions like Compute or Size.

A MapOf must not be copied after first use.

MapOf uses a modified version of Cache\-Line Hash Table \(CLHT\) data structure: https://github.com/LPD-EPFL/CLHT

CLHT is built around idea to organize the hash table in cache\-line\-sized buckets, so that on all modern CPUs update operations complete with at most one cache\-line transfer. Also, Get operations involve no write to memory, as well as no mutexes or any other sort of locks. Due to this design, in all considered scenarios MapOf outperforms sync.Map.

```go
type MapOf[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewMapOf"></a>
### func NewMapOf

```go
func NewMapOf[K comparable, V any]() *MapOf[K, V]
```

NewMapOf creates a new MapOf instance.

<a name="NewMapOfPresized"></a>
### func NewMapOfPresized

```go
func NewMapOfPresized[K comparable, V any](sizeHint int) *MapOf[K, V]
```

NewMapOfPresized creates a new MapOf instance with capacity enough to hold sizeHint entries. The capacity is treated as the minimal capacity meaning that the underlying hash table will never shrink to a smaller capacity. If sizeHint is zero or negative, the value is ignored.

<a name="MapOf[K, V].Clear"></a>
### func \(\*MapOf\[K, V\]\) Clear

```go
func (m *MapOf[K, V]) Clear()
```

Clear deletes all keys and values currently stored in the map.

<a name="MapOf[K, V].Compute"></a>
### func \(\*MapOf\[K, V\]\) Compute

```go
func (m *MapOf[K, V]) Compute(key K, valueFn func(oldValue V, loaded bool) (newValue V, delete bool)) (actual V, ok bool)
```

Compute either sets the computed new value for the key or deletes the value for the key. When the delete result of the valueFn function is set to true, the value will be deleted, if it exists. When delete is set to false, the value is updated to the newValue. The ok result indicates whether value was computed and stored, thus, is present in the map. The actual result contains the new value in cases where the value was computed and stored. See the example for a few use cases.

This call locks a hash table bucket while the compute function is executed. It means that modifications on other entries in the bucket will be blocked until the valueFn executes. Consider this when the function includes long\-running operations.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"errors"
	"fmt"

	"github.com/fufuok/utils/xsync"
)

func main() {
	counts := xsync.NewMapOf[int, int]()

	// Store a new value.
	v, ok := counts.Compute(42, func(oldValue int, loaded bool) (newValue int, delete bool) {
		// loaded is false here.
		newValue = 42
		delete = false
		return
	})
	// v: 42, ok: true
	fmt.Printf("v: %v, ok: %v\n", v, ok)

	// Update an existing value.
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, delete bool) {
		// loaded is true here.
		newValue = oldValue + 42
		delete = false
		return
	})
	// v: 84, ok: true
	fmt.Printf("v: %v, ok: %v\n", v, ok)

	// Set a new value or keep the old value conditionally.
	var oldVal int
	minVal := 63
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, delete bool) {
		oldVal = oldValue
		if !loaded || oldValue < minVal {
			newValue = minVal
			delete = false
			return
		}
		newValue = oldValue
		delete = false
		return
	})
	// v: 84, ok: true, oldVal: 84
	fmt.Printf("v: %v, ok: %v, oldVal: %v\n", v, ok, oldVal)

	// Delete an existing value.
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, delete bool) {
		// loaded is true here.
		delete = true
		return
	})
	// v: 84, ok: false
	fmt.Printf("v: %v, ok: %v\n", v, ok)

	// Propagate an error from the compute function to the outer scope.
	var err error
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, delete bool) {
		if oldValue == 42 {
			err = errors.New("something went wrong")
			return 0, true // no need to create a key/value pair
		}
		newValue = 0
		delete = false
		return
	})
	fmt.Printf("err: %v\n", err)
}
```

</p>
</details>

<a name="MapOf[K, V].Delete"></a>
### func \(\*MapOf\[K, V\]\) Delete

```go
func (m *MapOf[K, V]) Delete(key K)
```

Delete deletes the value for a key.

<a name="MapOf[K, V].Load"></a>
### func \(\*MapOf\[K, V\]\) Load

```go
func (m *MapOf[K, V]) Load(key K) (value V, ok bool)
```

Load returns the value stored in the map for a key, or zero value of type V if no value is present. The ok result indicates whether value was found in the map.

<a name="MapOf[K, V].LoadAndDelete"></a>
### func \(\*MapOf\[K, V\]\) LoadAndDelete

```go
func (m *MapOf[K, V]) LoadAndDelete(key K) (value V, loaded bool)
```

LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.

<a name="MapOf[K, V].LoadAndStore"></a>
### func \(\*MapOf\[K, V\]\) LoadAndStore

```go
func (m *MapOf[K, V]) LoadAndStore(key K, value V) (actual V, loaded bool)
```

LoadAndStore returns the existing value for the key if present, while setting the new value for the key. It stores the new value and returns the existing one, if present. The loaded result is true if the existing value was loaded, false otherwise.

<a name="MapOf[K, V].LoadOrCompute"></a>
### func \(\*MapOf\[K, V\]\) LoadOrCompute

```go
func (m *MapOf[K, V]) LoadOrCompute(key K, valueFn func() V) (actual V, loaded bool)
```

LoadOrCompute returns the existing value for the key if present. Otherwise, it computes the value using the provided function and returns the computed value. The loaded result is true if the value was loaded, false if stored.

This call locks a hash table bucket while the compute function is executed. It means that modifications on other entries in the bucket will be blocked until the valueFn executes. Consider this when the function includes long\-running operations.

<a name="MapOf[K, V].LoadOrStore"></a>
### func \(\*MapOf\[K, V\]\) LoadOrStore

```go
func (m *MapOf[K, V]) LoadOrStore(key K, value V) (actual V, loaded bool)
```

LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.

<a name="MapOf[K, V].Range"></a>
### func \(\*MapOf\[K, V\]\) Range

```go
func (m *MapOf[K, V]) Range(f func(key K, value V) bool)
```

Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.

Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.

It is safe to modify the map while iterating it, including entry creation, modification and deletion. However, the concurrent modification rule apply, i.e. the changes may be not reflected in the subsequently iterated entries.

<a name="MapOf[K, V].Size"></a>
### func \(\*MapOf\[K, V\]\) Size

```go
func (m *MapOf[K, V]) Size() int
```

Size returns current size of the map.

<a name="MapOf[K, V].Store"></a>
### func \(\*MapOf\[K, V\]\) Store

```go
func (m *MapOf[K, V]) Store(key K, value V)
```

Store sets the value for a key.

<a name="RBMutex"></a>
## type RBMutex

A RBMutex is a reader biased reader/writer mutual exclusion lock. The lock can be held by an many readers or a single writer. The zero value for a RBMutex is an unlocked mutex.

A RBMutex must not be copied after first use.

RBMutex is based on a modified version of BRAVO \(Biased Locking for Reader\-Writer Locks\) algorithm: https://arxiv.org/pdf/1810.01553.pdf

RBMutex is a specialized mutex for scenarios, such as caches, where the vast majority of locks are acquired by readers and write lock acquire attempts are infrequent. In such scenarios, RBMutex performs better than sync.RWMutex on large multicore machines.

RBMutex extends sync.RWMutex internally and uses it as the "reader bias disabled" fallback, so the same semantics apply. The only noticeable difference is in reader tokens returned from the RLock/RUnlock methods.

```go
type RBMutex struct {
    // contains filtered or unexported fields
}
```

<a name="NewRBMutex"></a>
### func NewRBMutex

```go
func NewRBMutex() *RBMutex
```

NewRBMutex creates a new RBMutex instance.

<a name="RBMutex.Lock"></a>
### func \(\*RBMutex\) Lock

```go
func (mu *RBMutex) Lock()
```

Lock locks m for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.

<a name="RBMutex.RLock"></a>
### func \(\*RBMutex\) RLock

```go
func (mu *RBMutex) RLock() *RToken
```

RLock locks m for reading and returns a reader token. The token must be used in the later RUnlock call.

Should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock.

<a name="RBMutex.RUnlock"></a>
### func \(\*RBMutex\) RUnlock

```go
func (mu *RBMutex) RUnlock(t *RToken)
```

RUnlock undoes a single RLock call. A reader token obtained from the RLock call must be provided. RUnlock does not affect other simultaneous readers. A panic is raised if m is not locked for reading on entry to RUnlock.

<a name="RBMutex.Unlock"></a>
### func \(\*RBMutex\) Unlock

```go
func (mu *RBMutex) Unlock()
```

Unlock unlocks m for writing. A panic is raised if m is not locked for writing on entry to Unlock.

As with RWMutex, a locked RBMutex is not associated with a particular goroutine. One goroutine may RLock \(Lock\) a RBMutex and then arrange for another goroutine to RUnlock \(Unlock\) it.

<a name="RToken"></a>
## type RToken

RToken is a reader lock token.

```go
type RToken struct {
    // contains filtered or unexported fields
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
